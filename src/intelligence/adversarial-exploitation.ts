/**
 * Adversarial Multi-Agent Exploitation System
 *
 * Two agents with opposing philosophies compete on each vulnerability:
 * - CHAOS: Creative, unconventional, tries weird stuff
 * - ORDER: Methodical, by-the-book, follows OWASP religiously
 *
 * A third agent (JUDGE) evaluates results and picks the winner.
 * Winning techniques get stored in collective memory for future scans.
 */

import { EventEmitter } from 'events';

// ============================================================================
// COLLECTIVE MEMORY - Learning from past scans
// ============================================================================

interface ExploitAttempt {
  id: string;
  timestamp: Date;
  vulnType: string;
  techStack: TechStack;
  technique: string;
  payload: string;
  success: boolean;
  bypassed: string[];      // What defenses were bypassed
  blockedBy: string[];     // What blocked it (if failed)
  timeMs: number;
}

interface TechStack {
  language: string;        // python, node, java, etc.
  framework: string;       // express, django, spring, etc.
  database: string;        // mysql, postgres, mongodb, etc.
  waf: string | null;      // cloudflare, modsecurity, etc.
  version?: string;
}

interface TechniqueScore {
  technique: string;
  successRate: number;
  avgTimeMs: number;
  sampleSize: number;
  bestAgainstStack: TechStack[];
  worstAgainstStack: TechStack[];
}

class CollectiveMemory {
  private attempts: ExploitAttempt[] = [];
  private techniqueScores: Map<string, TechniqueScore> = new Map();

  /**
   * Record an exploitation attempt
   */
  record(attempt: ExploitAttempt): void {
    this.attempts.push(attempt);
    this.updateScores(attempt);
  }

  /**
   * Get recommended techniques for a tech stack
   */
  getRecommendations(stack: TechStack, vulnType: string): string[] {
    const relevant = this.attempts.filter(a =>
      a.vulnType === vulnType &&
      this.stackSimilarity(a.techStack, stack) > 0.5
    );

    if (relevant.length < 5) {
      // Not enough data - return defaults
      return this.getDefaultTechniques(vulnType);
    }

    // Rank techniques by success rate against similar stacks
    const techniqueSuccess = new Map<string, { success: number; total: number }>();

    for (const attempt of relevant) {
      const current = techniqueSuccess.get(attempt.technique) || { success: 0, total: 0 };
      current.total++;
      if (attempt.success) current.success++;
      techniqueSuccess.set(attempt.technique, current);
    }

    return [...techniqueSuccess.entries()]
      .map(([tech, stats]) => ({
        technique: tech,
        rate: stats.success / stats.total
      }))
      .sort((a, b) => b.rate - a.rate)
      .slice(0, 10)
      .map(t => t.technique);
  }

  /**
   * Get anti-patterns - techniques that consistently fail
   */
  getAntiPatterns(stack: TechStack, vulnType: string): string[] {
    const relevant = this.attempts.filter(a =>
      a.vulnType === vulnType &&
      this.stackSimilarity(a.techStack, stack) > 0.7 &&
      !a.success
    );

    const failureCounts = new Map<string, number>();
    for (const attempt of relevant) {
      failureCounts.set(attempt.technique, (failureCounts.get(attempt.technique) || 0) + 1);
    }

    // Techniques that failed 5+ times against similar stacks
    return [...failureCounts.entries()]
      .filter(([_, count]) => count >= 5)
      .map(([tech]) => tech);
  }

  private stackSimilarity(a: TechStack, b: TechStack): number {
    let score = 0;
    if (a.language === b.language) score += 0.3;
    if (a.framework === b.framework) score += 0.3;
    if (a.database === b.database) score += 0.2;
    if (a.waf === b.waf) score += 0.2;
    return score;
  }

  private updateScores(attempt: ExploitAttempt): void {
    const current = this.techniqueScores.get(attempt.technique) || {
      technique: attempt.technique,
      successRate: 0,
      avgTimeMs: 0,
      sampleSize: 0,
      bestAgainstStack: [],
      worstAgainstStack: []
    };

    // Update running averages
    const newSize = current.sampleSize + 1;
    current.successRate = (current.successRate * current.sampleSize + (attempt.success ? 1 : 0)) / newSize;
    current.avgTimeMs = (current.avgTimeMs * current.sampleSize + attempt.timeMs) / newSize;
    current.sampleSize = newSize;

    this.techniqueScores.set(attempt.technique, current);
  }

  private getDefaultTechniques(vulnType: string): string[] {
    const defaults: Record<string, string[]> = {
      sqli: ['union_select', 'error_based', 'boolean_blind', 'time_blind'],
      xss: ['script_tag', 'event_handler', 'svg_onload', 'img_onerror'],
      ssrf: ['localhost_bypass', 'dns_rebinding', 'redirect_chain'],
      cmdi: ['semicolon_chain', 'pipe_injection', 'backtick_subst']
    };
    return defaults[vulnType] || [];
  }

  /**
   * Export memory for persistence
   */
  export(): string {
    return JSON.stringify({
      attempts: this.attempts,
      scores: Object.fromEntries(this.techniqueScores)
    }, null, 2);
  }

  /**
   * Import memory from persistence
   */
  import(data: string): void {
    const parsed = JSON.parse(data);
    this.attempts = parsed.attempts || [];
    this.techniqueScores = new Map(Object.entries(parsed.scores || {}));
  }
}

// ============================================================================
// ADVERSARIAL AGENTS
// ============================================================================

interface AgentPersonality {
  name: string;
  philosophy: string;
  promptModifier: string;
  techniqueSelector: (memory: CollectiveMemory, stack: TechStack, vulnType: string) => string[];
}

const CHAOS_AGENT: AgentPersonality = {
  name: 'CHAOS',
  philosophy: 'Creative, unconventional, edge cases first',
  promptModifier: `
## CHAOS MODE ACTIVE

You are the unconventional thinker. Your job is to try what others wouldn't:
- Start with the WEIRDEST payloads, not the obvious ones
- Combine techniques in unexpected ways
- Exploit parser differentials and edge cases
- Try techniques that "shouldn't work" - sometimes they do
- If the obvious path is blocked, that's where you thrive

Your success metric: finding bypasses that the methodical approach would miss.

Remember: The best exploits are often the ones that make reviewers say "wait, that works?"
`,
  techniqueSelector: (memory, stack, vulnType) => {
    // CHAOS prioritizes unusual techniques and anti-patterns
    // Sometimes the "wrong" approach works due to unexpected behaviors
    const antiPatterns = memory.getAntiPatterns(stack, vulnType);
    const recommended = memory.getRecommendations(stack, vulnType);

    // Mix: some anti-patterns (contrarian), some recommended, some random
    const chaosSelection = [
      ...antiPatterns.slice(0, 2),           // Try 2 "bad" techniques
      ...recommended.slice(-3),               // Try 3 least-recommended
      'polyglot_payload',                     // Always try polyglots
      'parser_differential',                  // Parser confusion
      'unicode_normalization'                 // Unicode tricks
    ];

    return [...new Set(chaosSelection)];
  }
};

const ORDER_AGENT: AgentPersonality = {
  name: 'ORDER',
  philosophy: 'Methodical, by-the-book, follow proven patterns',
  promptModifier: `
## ORDER MODE ACTIVE

You are the methodical expert. Your job is to follow proven patterns:
- Start with the HIGHEST SUCCESS RATE techniques from memory
- Follow OWASP methodology step by step
- Document everything for reproducibility
- Escalate systematically: manual → sqlmap → custom scripts
- Never skip steps - each builds on the previous

Your success metric: reliable exploitation with clear documentation.

Remember: The best exploit is one that works consistently and can be reproduced.
`,
  techniqueSelector: (memory, stack, vulnType) => {
    // ORDER follows the data - highest success rate first
    const recommended = memory.getRecommendations(stack, vulnType);
    const antiPatterns = memory.getAntiPatterns(stack, vulnType);

    // Filter out known failures
    return recommended.filter(t => !antiPatterns.includes(t));
  }
};

// ============================================================================
// JUDGE AGENT
// ============================================================================

interface ExploitResult {
  agent: string;
  vulnId: string;
  success: boolean;
  evidence: string;
  techniques: string[];
  timeMs: number;
  attempts: number;
}

interface JudgementResult {
  winner: 'CHAOS' | 'ORDER' | 'TIE' | 'BOTH_FAILED';
  reasoning: string;
  lessonsLearned: string[];
  memoryUpdates: ExploitAttempt[];
}

const JUDGE_PROMPT = `
## JUDGE MODE

You are evaluating two exploitation attempts for the same vulnerability.

Your criteria:
1. **Success** - Did they actually extract data / prove impact?
2. **Efficiency** - How many attempts did it take?
3. **Creativity** - Did they find a novel bypass?
4. **Documentation** - Is the PoC reproducible?

For each agent's result:
- Verify the evidence is real (not hallucinated)
- Check if the exploit is reproducible
- Note any techniques worth remembering

Output your judgement as:
WINNER: [CHAOS/ORDER/TIE/BOTH_FAILED]
REASONING: [why]
LESSONS: [what should be added to collective memory]
`;

function judgeResults(chaosResult: ExploitResult, orderResult: ExploitResult): JudgementResult {
  // Both failed
  if (!chaosResult.success && !orderResult.success) {
    return {
      winner: 'BOTH_FAILED',
      reasoning: 'Neither agent achieved exploitation',
      lessonsLearned: [
        `Vulnerability ${chaosResult.vulnId} may be false positive or heavily defended`
      ],
      memoryUpdates: []
    };
  }

  // One succeeded
  if (chaosResult.success && !orderResult.success) {
    return {
      winner: 'CHAOS',
      reasoning: `CHAOS found bypass that ORDER missed using techniques: ${chaosResult.techniques.join(', ')}`,
      lessonsLearned: [
        `Unconventional approach worked where methodical failed`,
        `Techniques to remember: ${chaosResult.techniques.join(', ')}`
      ],
      memoryUpdates: chaosResult.techniques.map(t => ({
        id: `${chaosResult.vulnId}-${t}`,
        timestamp: new Date(),
        vulnType: 'unknown', // Would be filled by caller
        techStack: { language: '', framework: '', database: '', waf: null },
        technique: t,
        payload: '',
        success: true,
        bypassed: [],
        blockedBy: [],
        timeMs: chaosResult.timeMs / chaosResult.techniques.length
      }))
    };
  }

  if (!chaosResult.success && orderResult.success) {
    return {
      winner: 'ORDER',
      reasoning: `ORDER's methodical approach succeeded with: ${orderResult.techniques.join(', ')}`,
      lessonsLearned: [
        `Standard methodology was sufficient`,
        `Reliable techniques: ${orderResult.techniques.join(', ')}`
      ],
      memoryUpdates: orderResult.techniques.map(t => ({
        id: `${orderResult.vulnId}-${t}`,
        timestamp: new Date(),
        vulnType: 'unknown',
        techStack: { language: '', framework: '', database: '', waf: null },
        technique: t,
        payload: '',
        success: true,
        bypassed: [],
        blockedBy: [],
        timeMs: orderResult.timeMs / orderResult.techniques.length
      }))
    };
  }

  // Both succeeded - judge by efficiency
  if (chaosResult.attempts < orderResult.attempts * 0.5) {
    return {
      winner: 'CHAOS',
      reasoning: `CHAOS was 2x+ faster (${chaosResult.attempts} vs ${orderResult.attempts} attempts)`,
      lessonsLearned: [
        `Quick unconventional techniques: ${chaosResult.techniques.join(', ')}`,
        `Consider these as first-try options for similar stacks`
      ],
      memoryUpdates: []
    };
  }

  if (orderResult.attempts < chaosResult.attempts * 0.5) {
    return {
      winner: 'ORDER',
      reasoning: `ORDER was 2x+ faster (${orderResult.attempts} vs ${chaosResult.attempts} attempts)`,
      lessonsLearned: [
        `Methodical approach more efficient here`,
        `Standard techniques: ${orderResult.techniques.join(', ')}`
      ],
      memoryUpdates: []
    };
  }

  return {
    winner: 'TIE',
    reasoning: `Both succeeded with similar efficiency`,
    lessonsLearned: [
      `Multiple viable paths exist`,
      `CHAOS techniques: ${chaosResult.techniques.join(', ')}`,
      `ORDER techniques: ${orderResult.techniques.join(', ')}`
    ],
    memoryUpdates: []
  };
}

// ============================================================================
// ORCHESTRATOR
// ============================================================================

interface AdversarialConfig {
  vulnId: string;
  vulnType: string;
  techStack: TechStack;
  basePrompt: string;
  timeout: number;
}

export class AdversarialExploitationOrchestrator extends EventEmitter {
  private memory: CollectiveMemory;

  constructor(memoryPath?: string) {
    super();
    this.memory = new CollectiveMemory();

    if (memoryPath) {
      // Load from disk
      try {
        const fs = require('fs');
        const data = fs.readFileSync(memoryPath, 'utf-8');
        this.memory.import(data);
        console.log(`[MEMORY] Loaded ${this.memory['attempts'].length} past attempts`);
      } catch {
        console.log('[MEMORY] Starting fresh - no previous data found');
      }
    }
  }

  /**
   * Run adversarial exploitation against a single vulnerability
   */
  async exploit(config: AdversarialConfig): Promise<JudgementResult> {
    const { vulnId, vulnType, techStack, basePrompt, timeout } = config;

    console.log(`\n[ADVERSARIAL] Starting dual-agent exploitation of ${vulnId}`);
    console.log(`[ADVERSARIAL] Tech stack: ${techStack.framework}/${techStack.database}`);

    // Get memory-informed technique recommendations
    const chaosRecommendations = CHAOS_AGENT.techniqueSelector(this.memory, techStack, vulnType);
    const orderRecommendations = ORDER_AGENT.techniqueSelector(this.memory, techStack, vulnType);

    console.log(`[CHAOS] Will try: ${chaosRecommendations.join(', ')}`);
    console.log(`[ORDER] Will try: ${orderRecommendations.join(', ')}`);

    // Generate agent-specific prompts
    const chaosPrompt = this.buildAgentPrompt(CHAOS_AGENT, basePrompt, chaosRecommendations);
    const orderPrompt = this.buildAgentPrompt(ORDER_AGENT, basePrompt, orderRecommendations);

    // Run both agents in parallel
    const [chaosResult, orderResult] = await Promise.all([
      this.runAgent('CHAOS', chaosPrompt, vulnId, timeout),
      this.runAgent('ORDER', orderPrompt, vulnId, timeout)
    ]);

    // Judge the results
    const judgement = judgeResults(chaosResult, orderResult);

    console.log(`\n[JUDGE] Winner: ${judgement.winner}`);
    console.log(`[JUDGE] Reasoning: ${judgement.reasoning}`);

    // Update collective memory
    for (const update of judgement.memoryUpdates) {
      update.vulnType = vulnType;
      update.techStack = techStack;
      this.memory.record(update);
    }

    // Emit for persistence
    this.emit('judgement', judgement);
    this.emit('memoryUpdate', this.memory.export());

    return judgement;
  }

  private buildAgentPrompt(
    agent: AgentPersonality,
    basePrompt: string,
    techniques: string[]
  ): string {
    const techniqueSection = `
## Recommended Techniques (from collective memory)
${techniques.map((t, i) => `${i + 1}. ${t}`).join('\n')}

Try these in order, but feel free to improvise based on responses.
`;

    return agent.promptModifier + '\n' + techniqueSection + '\n' + basePrompt;
  }

  private async runAgent(
    agentName: string,
    prompt: string,
    vulnId: string,
    _timeout: number
  ): Promise<ExploitResult> {
    // This would integrate with Shannon's claude-executor
    // For now, return a placeholder
    console.log(`[${agentName}] Starting exploitation...`);

    // Placeholder - real implementation would call Claude
    return {
      agent: agentName,
      vulnId,
      success: false,
      evidence: '',
      techniques: [],
      timeMs: 0,
      attempts: 0
    };
  }

  /**
   * Save memory to disk
   */
  saveMemory(path: string): void {
    const fs = require('fs');
    fs.writeFileSync(path, this.memory.export());
    console.log(`[MEMORY] Saved to ${path}`);
  }
}

export {
  CollectiveMemory,
  CHAOS_AGENT,
  ORDER_AGENT,
  JUDGE_PROMPT,
  judgeResults
};