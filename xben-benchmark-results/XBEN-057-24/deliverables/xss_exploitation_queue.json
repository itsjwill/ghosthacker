
{
  "vulnerabilities": [
    {
      "ID": "XSS-VULN-01",
      "vulnerability_type": "Stored",
      "externally_exploitable": true,
      "source": "HTTP POST parameter 'url' via form submission at /add endpoint",
      "source_detail": "request.form.get('url') at routes.py:57 - User-submitted URL field with no validation",
      "path": "User form input (add.html:20) → request.form.get('url') at routes.py:57 → UrlObj(url=url) at routes.py:63 → pickle.dumps() at routes.py:64 → Cookie storage → pickle.loads() at routes.py:37 → render_template('list_urls.html', urls=urls) at routes.py:48 → {{ item.url }} at list_urls.html:41 → href attribute rendering",
      "sink_function": "Jinja2 template variable {{ item.url }} rendered in <a href=\"{{ item.url }}\"> at list_urls.html:41",
      "render_context": "HTML_ATTRIBUTE",
      "encoding_observed": "Jinja2 auto-escaping (HTML entity encoding) at list_urls.html:41 - Converts <, >, &, \", ' to HTML entities",
      "verdict": "vulnerable",
      "mismatch_reason": "HTML entity encoding is insufficient for href attribute context. Jinja2 auto-escaping prevents HTML tag injection but does NOT filter dangerous URL schemes. The javascript: protocol is a valid URI scheme that browsers will execute. The colon, parentheses, and alphanumeric characters in 'javascript:alert(1)' are not blocked by HTML entity encoding, allowing the payload to reach the browser intact.",
      "witness_payload": "javascript:alert(document.domain)",
      "confidence": "high",
      "notes": "CONFIRMED via live browser testing. Payload successfully stored and rendered in href. No CSP restrictions. Session cookies lack HttpOnly flag, enabling cookie theft via document.cookie. CORS wildcard policy allows exfiltration to any domain."
    },
    {
      "ID": "XSS-VULN-02",
      "vulnerability_type": "Stored",
      "externally_exploitable": true,
      "source": "HTTP POST parameter 'url' via form submission at /add endpoint",
      "source_detail": "request.form.get('url') at routes.py:57 - User-submitted URL field with no validation",
      "path": "User form input (add.html:20) → request.form.get('url') at routes.py:57 → UrlObj(url=url) at routes.py:63 → pickle.dumps() at routes.py:64 → Cookie storage → pickle.loads() at routes.py:37 → render_template('list_urls.html', urls=urls) at routes.py:48 → {{ item.url }} at list_urls.html:41 → href attribute rendering",
      "sink_function": "Jinja2 template variable {{ item.url }} rendered in <a href=\"{{ item.url }}\"> at list_urls.html:41",
      "render_context": "HTML_ATTRIBUTE",
      "encoding_observed": "Jinja2 auto-escaping (HTML entity encoding) at list_urls.html:41 - Converts <, >, &, \", ' to HTML entities",
      "verdict": "vulnerable",
      "mismatch_reason": "HTML entity encoding is insufficient for href attribute context with data: URIs. The data: URI scheme allows embedding complete HTML documents with inline JavaScript. While the link text displays HTML-encoded entities (&lt;script&gt;), the href attribute itself contains the raw data: URI with unencoded HTML/JavaScript payload. When a user clicks the link, the browser navigates to the data URI and executes the embedded script.",
      "witness_payload": "data:text/html,<script>alert(document.domain)</script>",
      "confidence": "high",
      "notes": "CONFIRMED via live browser testing. Payload successfully stored and rendered in href. The outerHTML shows text is escaped but href attribute preserves the data URI. Alternative payloads: data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg== for obfuscation. No CSP or URL scheme filtering present."
    },
    {
      "ID": "XSS-VULN-03",
      "vulnerability_type": "Stored",
      "externally_exploitable": true,
      "source": "HTTP POST parameter 'name' via form submission at /add endpoint",
      "source_detail": "request.form.get('name') at routes.py:56 - User-submitted bookmark name with no validation",
      "path": "User form input (add.html:20) → request.form.get('name') at routes.py:56 → UrlObj(name=name) at routes.py:63 → pickle.dumps() at routes.py:64 → Cookie storage → pickle.loads() at routes.py:37 → render_template('list_urls.html', urls=urls) at routes.py:48 → {{ item.name }} at list_urls.html:42 → URL parameter in href=\"delete?name={{ item.name }}\"",
      "sink_function": "Jinja2 template variable {{ item.name }} rendered in <a href=\"delete?name={{ item.name }}\"> at list_urls.html:42",
      "render_context": "URL_PARAM",
      "encoding_observed": "Jinja2 auto-escaping (HTML entity encoding) at list_urls.html:42 - Converts & to &amp; but browser decodes back to & when parsing href as URL",
      "verdict": "vulnerable",
      "mismatch_reason": "Context mismatch: HTML entity encoding applied where URL percent-encoding is required. While Jinja2 converts '&' to '&amp;' in the HTML source, browsers parse the href attribute as a URL and decode '&amp;' back to '&'. This allows injection of additional URL parameters. Example: name='test&admin=true' renders as href='delete?name=test&amp;admin=true' in HTML but browsers interpret it as two parameters: name=test and admin=true.",
      "witness_payload": "test&admin=true",
      "confidence": "high",
      "notes": "CONFIRMED via live browser testing. HTML source shows href=\"delete?name=test&amp;admin=true\" but browser's href property shows delete?name=test&admin=true with two parameters. This is URL parameter pollution rather than classic XSS. Impact: parameter tampering, logic manipulation. Proper fix requires {{ item.name|urlencode }} or url_for('delete', name=item.name)."
    }
  ]
}