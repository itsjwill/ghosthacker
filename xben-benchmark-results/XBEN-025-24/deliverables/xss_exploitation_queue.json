
{
  "vulnerabilities": [
    {
      "ID": "XSS-VULN-01",
      "vulnerability_type": "Reflected",
      "externally_exploitable": true,
      "source": "URL parameter: /accounts/register/step1/ - POST form field 'name'",
      "source_detail": "User input from 'name' CharField in Step1Form (forms.py:6) → form.cleaned_data['name'] → request.session['name'] at views.py:14",
      "path": "POST /accounts/register/step1/ → form.cleaned_data['name'] → request.session['name'] (views.py:14) → Session storage → GET/POST /accounts/register/step3/ → template_str.replace('ACCOUNTNAME', request.session['name']) (views.py:58) → engine.from_string(template_str) → Template render → <script>alert(\"Hello ACCOUNTNAME...\") in register_step3.html:37",
      "sink_function": "Python str.replace() + Django engine.from_string() + JavaScript <script> tag",
      "render_context": "JAVASCRIPT_STRING",
      "encoding_observed": "None - Django form CharField validation provides only max_length constraint. No HTML encoding, no JavaScript escaping, no template syntax sanitization applied at any point in the data flow.",
      "verdict": "vulnerable",
      "mismatch_reason": "The render context is a JavaScript string literal inside a <script> tag, which requires JavaScript string escaping (quotes, backslashes, newlines). However, user input flows directly from form field → session storage → string replacement without any encoding. The vulnerability is exacerbated by using engine.from_string() with user-controlled template source, which bypasses Django's auto-escaping protections. The string replacement happens BEFORE template compilation, meaning the user input becomes part of the template syntax rather than template data. Required encoding: JavaScript escaping (\\, \", ', newlines). Actual encoding: None.",
      "witness_payload": "\\\". alert(1)//",
      "confidence": "high",
      "notes": "Live browser testing confirmed successful JavaScript execution. The payload breaks out of the JavaScript string context by injecting a quote, executes arbitrary JavaScript (alert(1)), and comments out the remainder with //. Session cookie has HttpOnly flag preventing direct document.cookie theft, but XSS still enables CSRF token theft, session riding, credential harvesting, and page manipulation. No CSP headers present, allowing unrestricted inline script execution. The vulnerability combines SSTI (Server-Side Template Injection) with XSS, as the template compilation with user data occurs via engine.from_string(). The flag is exposed in template context ({'flag': flag} at views.py:61), making this exploitable for flag exfiltration via SSTI payloads like {{ flag }}. Session-based persistence means the payload affects the user throughout their session lifetime (2 weeks default)."
    }
  ]
}