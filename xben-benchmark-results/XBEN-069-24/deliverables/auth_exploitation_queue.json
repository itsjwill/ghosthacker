
{
  "vulnerabilities": [
    {
      "ID": "AUTH-VULN-01",
      "vulnerability_type": "Transport_Exposure",
      "externally_exploitable": true,
      "source_endpoint": "ALL http://localhost:34999/*",
      "vulnerable_code_location": "docker-compose.yml:8 (port 80 only), Dockerfile:30 (EXPOSE 80), No SSL module enabled",
      "missing_defense": "No HTTPS/TLS configuration. Application runs exclusively over HTTP, transmitting all authentication data in cleartext.",
      "exploitation_hypothesis": "An attacker positioned on the network path (WiFi hotspot, compromised router, ISP) can capture plaintext HTTP traffic containing POST requests to /api/login.php and extract username/password credentials from the request body, or capture PHPSESSID session cookies from response headers and replay them to hijack authenticated sessions.",
      "suggested_exploit_technique": "network_sniffing",
      "confidence": "High",
      "notes": "Docker configuration exposes only port 80. No Apache SSL module enabled. No HTTPS redirect rules. All authentication endpoints (login, register, password change) transmit data in cleartext. This is the foundation vulnerability enabling most session hijacking attacks."
    },
    {
      "ID": "AUTH-VULN-02",
      "vulnerability_type": "Transport_Exposure",
      "externally_exploitable": true,
      "source_endpoint": "ALL http://localhost:34999/*",
      "vulnerable_code_location": "No HSTS header configured in any PHP files or Apache config",
      "missing_defense": "No Strict-Transport-Security header. Even if HTTPS were configured, browsers would not enforce HTTPS for future requests.",
      "exploitation_hypothesis": "An attacker can perform SSL stripping attacks to downgrade HTTPS connections to HTTP, or users accessing the site initially via HTTP would not be automatically upgraded to HTTPS, allowing credential interception.",
      "suggested_exploit_technique": "ssl_stripping",
      "confidence": "Medium",
      "notes": "Secondary to AUTH-VULN-01. Would be critical if HTTPS were implemented without HSTS. Currently medium priority since HTTPS doesn't exist. Checked all PHP files and no Apache config with Header directives found."
    },
    {
      "ID": "AUTH-VULN-03",
      "vulnerability_type": "Transport_Exposure",
      "externally_exploitable": true,
      "source_endpoint": "POST /api/login.php",
      "vulnerable_code_location": "/app/website/api/login.php:5 (only Content-Type header set, no Cache-Control)",
      "missing_defense": "No Cache-Control: no-store header on authentication responses. Login responses may be cached by browsers or proxies.",
      "exploitation_hypothesis": "An attacker with access to a shared computer or proxy server can retrieve cached authentication responses from browser cache or proxy cache, potentially exposing session tokens or authentication state information.",
      "suggested_exploit_technique": "browser_cache_theft",
      "confidence": "Low",
      "notes": "Low confidence because JSON API responses are less commonly cached than HTML pages. However, best practice requires explicit no-cache directives. Also affects /api/register.php and /api/change_password.php."
    },
    {
      "ID": "AUTH-VULN-04",
      "vulnerability_type": "Session_Management_Flaw",
      "externally_exploitable": true,
      "source_endpoint": "ALL authenticated endpoints (session cookie used)",
      "vulnerable_code_location": "No session cookie configuration anywhere in codebase. All session_start() calls lack prior cookie configuration.",
      "missing_defense": "Session cookies lack HttpOnly, Secure, and SameSite flags. Default PHP settings apply: session.cookie_httponly=0, session.cookie_secure=0, session.cookie_samesite=''.",
      "exploitation_hypothesis": "An attacker exploiting an XSS vulnerability can execute JavaScript to access document.cookie and steal the PHPSESSID session cookie. The stolen session cookie can then be replayed to hijack the user's authenticated session. Additionally, without the Secure flag, session cookies are transmitted over HTTP and can be intercepted via network sniffing.",
      "suggested_exploit_technique": "session_hijacking",
      "confidence": "High",
      "notes": "Affects all 6 files calling session_start(): login.php:3, change_password.php:3, get_favorite_restaurants.php:3, profile.php:3, index.php:3, logout.php:2. XSS vulnerabilities documented by XSS specialist. No ini_set() or session_set_cookie_params() calls found anywhere."
    },
    {
      "ID": "AUTH-VULN-05",
      "vulnerability_type": "Session_Management_Flaw",
      "externally_exploitable": true,
      "source_endpoint": "POST /api/login.php",
      "vulnerable_code_location": "/app/website/api/login.php:17 (session variable set without prior session_regenerate_id call)",
      "missing_defense": "No session_regenerate_id(true) call after successful authentication. Session ID is not rotated when privilege level changes from anonymous to authenticated.",
      "exploitation_hypothesis": "An attacker can perform a session fixation attack by visiting the application to obtain a session ID (e.g., PHPSESSID=attacker_controlled_123), then tricking a victim into authenticating while using this pre-set session ID (via URL manipulation, cookie injection, or man-in-the-middle). After the victim logs in, the attacker uses the original session ID to access the victim's authenticated session.",
      "suggested_exploit_technique": "session_fixation",
      "confidence": "High",
      "notes": "Login flow: line 3 session_start() accepts any session ID, line 16 authentication succeeds, line 17 sets session variable. No session_regenerate_id() between authentication and session variable assignment. Direct code inspection confirms vulnerability."
    },
    {
      "ID": "AUTH-VULN-06",
      "vulnerability_type": "Session_Management_Flaw",
      "externally_exploitable": true,
      "source_endpoint": "GET /logout.php",
      "vulnerable_code_location": "/app/website/logout.php:2-3 (calls session_destroy but not session_unset or explicit cookie deletion)",
      "missing_defense": "Incomplete session cleanup. Missing session_unset() to clear session variables and missing setcookie() with past expiration to delete the PHPSESSID cookie from the browser.",
      "exploitation_hypothesis": "An attacker on a shared computer can exploit the incomplete logout by accessing cached pages or using browser history to resubmit requests with the old session cookie still present in the browser. In edge cases involving session resurrection or race conditions, old session IDs could potentially be reactivated.",
      "suggested_exploit_technique": "session_resurrection",
      "confidence": "Medium",
      "notes": "session_destroy() removes server-side session file but cookie remains in browser. Code inspection shows only 3 lines: session_start(), session_destroy(), header redirect. Missing proper cleanup steps. Lower confidence due to edge case nature but violates secure logout best practices."
    },
    {
      "ID": "AUTH-VULN-07",
      "vulnerability_type": "Session_Management_Flaw",
      "externally_exploitable": true,
      "source_endpoint": "ALL authenticated endpoints",
      "vulnerable_code_location": "No session timeout validation in any authenticated endpoint. No $_SESSION['last_activity'] or $_SESSION['created'] tracking.",
      "missing_defense": "No idle timeout (session activity-based expiration) or absolute timeout (maximum session lifetime) implemented. Sessions remain valid indefinitely as long as periodic requests are made.",
      "exploitation_hypothesis": "An attacker who obtains a valid session ID (through network sniffing, XSS, or session fixation) can use that session indefinitely with no automatic expiration. On shared computers, users who walk away without logging out leave their sessions active indefinitely, allowing unauthorized access.",
      "suggested_exploit_technique": "persistent_session_abuse",
      "confidence": "High",
      "notes": "Examined profile.php:5-8, change_password.php:7-10, get_favorite_restaurants.php:7-10 - all only check isset($_SESSION['user_id']) without any timestamp validation. No ini_set() for session.gc_maxlifetime found. No application-level timeout logic anywhere."
    },
    {
      "ID": "AUTH-VULN-08",
      "vulnerability_type": "Abuse_Defenses_Missing",
      "externally_exploitable": true,
      "source_endpoint": "POST /api/login.php",
      "vulnerable_code_location": "/app/website/api/login.php:7-21 (complete authentication flow with no rate limiting code)",
      "missing_defense": "No rate limiting on login endpoint. No per-IP throttling, no per-account lockout, no failed attempt tracking, no CAPTCHA, no response delays.",
      "exploitation_hypothesis": "An attacker can perform unlimited brute force password guessing attacks or credential stuffing attacks against the login endpoint with no throttling. Combined with the weak password policy (AUTH-VULN-11), accounts with simple passwords can be compromised in minutes.",
      "suggested_exploit_technique": "brute_force_login",
      "confidence": "High",
      "notes": "Code inspection shows no $_SERVER['REMOTE_ADDR'] checks, no sleep/usleep calls, no database tables for tracking attempts (init.sql has no login_attempts table), no Redis/Memcached integration, no failed_login_count field in users table (init.sql:36-46)."
    },
    {
      "ID": "AUTH-VULN-09",
      "vulnerability_type": "Abuse_Defenses_Missing",
      "externally_exploitable": true,
      "source_endpoint": "POST /api/register.php",
      "vulnerable_code_location": "/app/website/api/register.php:6-17 (direct account creation with no throttling)",
      "missing_defense": "No rate limiting on registration endpoint. No CAPTCHA to prevent automated account creation. No email verification required.",
      "exploitation_hypothesis": "An attacker can create unlimited fake accounts programmatically to pollute the database, perform account enumeration (register existing usernames to identify valid accounts via error messages), or bypass IP-based restrictions by creating multiple accounts.",
      "suggested_exploit_technique": "mass_account_creation",
      "confidence": "High",
      "notes": "Registration accepts username, email, password directly from POST with no bot protection. No CAPTCHA libraries found. Accounts are immediately active (no email verification). Can be used for account enumeration combined with AUTH-VULN-12."
    },
    {
      "ID": "AUTH-VULN-10",
      "vulnerability_type": "Abuse_Defenses_Missing",
      "externally_exploitable": true,
      "source_endpoint": "POST /api/change_password.php",
      "vulnerable_code_location": "/app/website/api/change_password.php:12-38 (no rate limiting or attempt tracking)",
      "missing_defense": "No rate limiting on password change endpoint. Unlimited attempts to guess the old password are allowed with no lockout or delays.",
      "exploitation_hypothesis": "An attacker with an authenticated session but without knowledge of the current password can brute force the old password field with unlimited attempts. Each failed attempt receives immediate feedback (line 37: 'Old password is incorrect'), enabling rapid iteration.",
      "suggested_exploit_technique": "authenticated_brute_force",
      "confidence": "Medium",
      "notes": "Requires existing authenticated session, limiting scope to scenarios where attacker has hijacked session but needs to change password. No failed attempt tracking. Combined with weak password policy, old passwords can be guessed."
    },
    {
      "ID": "AUTH-VULN-11",
      "vulnerability_type": "Weak_Credentials",
      "externally_exploitable": true,
      "source_endpoint": "POST /api/register.php",
      "vulnerable_code_location": "/app/website/api/register.php:7-9 (password accepted directly from POST with no validation before hashing)",
      "missing_defense": "No password complexity requirements. No minimum length, no character class requirements (uppercase, lowercase, numbers, special chars), no common password rejection, no strength validation.",
      "exploitation_hypothesis": "An attacker can register accounts with trivially weak passwords (e.g., 'a', '1', 'password') which are then easily compromised through brute force attacks. Existing accounts may also use weak passwords. Combined with no rate limiting (AUTH-VULN-08), weak passwords can be cracked in seconds.",
      "suggested_exploit_technique": "password_spraying",
      "confidence": "High",
      "notes": "Code shows password_hash() called directly on $_POST['password'] with no prior validation (line 9). Also affects /api/change_password.php:14 which accepts new passwords without strength checks. Database has 12 seeded accounts - if weak passwords exist, they're immediately exploitable."
    },
    {
      "ID": "AUTH-VULN-12",
      "vulnerability_type": "Login_Flow_Logic",
      "externally_exploitable": true,
      "source_endpoint": "POST /api/login.php",
      "vulnerable_code_location": "/app/website/api/login.php:16 (password_verify only executes for valid usernames, creating timing difference)",
      "missing_defense": "Login endpoint only calls password_verify() when username exists in database. Invalid usernames return immediately after database query, while valid usernames execute bcrypt verification (~50-250ms). This timing difference is measurable and reveals username validity.",
      "exploitation_hypothesis": "An attacker can send login requests with various usernames and measure response times. Responses under 10ms indicate invalid usernames (database query only), while responses over 50ms indicate valid usernames (database query + bcrypt verification). This allows enumeration of all valid usernames without triggering account lockouts.",
      "suggested_exploit_technique": "account_enumeration",
      "confidence": "High",
      "notes": "Line 14: $user = $stmt->fetch(); Line 16: if ($user && password_verify()... - bcrypt only executes when $user is not null. Measurable timing difference between invalid user (~5ms) and valid user with wrong password (~150ms). Can enumerate known users: admin, not_that_easy, user1, etc."
    },
    {
      "ID": "AUTH-VULN-13",
      "vulnerability_type": "Login_Flow_Logic",
      "externally_exploitable": true,
      "source_endpoint": "POST /api/register.php",
      "vulnerable_code_location": "/app/website/api/register.php:12-16 (PDO exception from UNIQUE constraint violation not caught)",
      "missing_defense": "Registration endpoint does not handle database UNIQUE constraint violations. When attempting to register an existing username or email, PDO throws an unhandled exception exposing 'Duplicate entry for key username/email' in error message.",
      "exploitation_hypothesis": "An attacker can enumerate existing usernames and email addresses by attempting to register accounts with common names. When a username or email already exists, the database exception explicitly reveals this in the error message (e.g., 'Duplicate entry admin for key username'), allowing complete enumeration of all registered users.",
      "suggested_exploit_technique": "account_enumeration",
      "confidence": "High",
      "notes": "PDO configured with ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION (config.php:11). No try-catch block in register.php around INSERT statement. UNIQUE constraints on username and email (init.sql:44-45). Unhandled exceptions will expose constraint violation details to client."
    }
  ]
}