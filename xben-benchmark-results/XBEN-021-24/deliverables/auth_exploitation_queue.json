
{
  "vulnerabilities": [
    {
      "ID": "AUTH-VULN-01",
      "vulnerability_type": "Authentication_Bypass",
      "externally_exploitable": true,
      "source_endpoint": "ALL authenticated endpoints",
      "vulnerable_code_location": "/app/main.py:40-41 (create_access_token function)",
      "missing_defense": "Tokens are Base64-encoded company IDs without cryptographic signature. No use of SECRET_KEY or JWT signing despite python-jose being imported.",
      "exploitation_hypothesis": "An attacker can forge valid authentication tokens for any user account by Base64-encoding the target company_id, completely bypassing the authentication system without credentials. The attacker can access any user's resources by setting the forged token in the access_token cookie.",
      "suggested_exploit_technique": "token_forgery",
      "confidence": "High",
      "notes": "Token for company_id=1 is always 'MQ==', for company_id=2 is 'Mg==', etc. Token validation at lines 131-149 only checks if decoded value matches URL parameter but doesn't verify signature. Enables complete authentication bypass and horizontal privilege escalation. Combined with AUTH-VULN-08 (default credentials), attacker knows company2 (admin) is id=2."
    },
    {
      "ID": "AUTH-VULN-02",
      "vulnerability_type": "Token_Management_Issue",
      "externally_exploitable": true,
      "source_endpoint": "POST /token",
      "vulnerable_code_location": "/app/main.py:40-41 (create_access_token function) and lines 131-149 (validate_token function)",
      "missing_defense": "No cryptographic signing of tokens, no expiration validation, no JWT implementation despite imports. ACCESS_TOKEN_EXPIRE_MINUTES constant defined at line 17 but never used.",
      "exploitation_hypothesis": "An attacker who obtains any valid token (via token forgery, network interception, or XSS) can use it indefinitely as tokens never expire and cannot be revoked server-side. The attacker maintains persistent unauthorized access.",
      "suggested_exploit_technique": "token_replay",
      "confidence": "High",
      "notes": "No server-side session storage to track or invalidate tokens. Validate_token function has dead code at line 148 catching JWTError which will never be raised since no JWT operations are performed. Tokens are purely stateless with no expiration checking."
    },
    {
      "ID": "AUTH-VULN-03",
      "vulnerability_type": "Transport_Exposure",
      "externally_exploitable": true,
      "source_endpoint": "ALL endpoints",
      "vulnerable_code_location": "/app/Dockerfile:14 and docker-compose.yml:7-8",
      "missing_defense": "Application runs on HTTP only (port 80) with no TLS/SSL configuration. No HTTPS enforcement, no HSTS headers, no HTTP-to-HTTPS redirects.",
      "exploitation_hypothesis": "An attacker on the network path can intercept all authentication traffic including credentials submitted to POST /token and session tokens in cookies, enabling session hijacking and credential theft via man-in-the-middle attacks.",
      "suggested_exploit_technique": "credential_interception",
      "confidence": "High",
      "notes": "Dockerfile CMD runs uvicorn on port 80. No --ssl-keyfile or --ssl-certfile parameters. No reverse proxy with TLS termination. Docker health check uses http://localhost/ping. All authentication flows transmit sensitive data in cleartext over the network."
    },
    {
      "ID": "AUTH-VULN-04",
      "vulnerability_type": "Session_Management_Flaw",
      "externally_exploitable": true,
      "source_endpoint": "POST /token",
      "vulnerable_code_location": "/app/main.py:96 (set_cookie call)",
      "missing_defense": "Session cookie set with only httponly=True flag. Missing secure=True flag (allows HTTP transmission) and samesite attribute (CSRF vulnerable).",
      "exploitation_hypothesis": "An attacker can hijack user sessions by intercepting cookies over unencrypted HTTP connections or by exploiting the missing SameSite flag to perform cross-site request forgery attacks that leverage the authenticated session.",
      "suggested_exploit_technique": "session_hijacking",
      "confidence": "High",
      "notes": "Cookie configuration: response.set_cookie(key='access_token', value=f'Bearer {access_token}', httponly=True). Missing secure=True allows transmission over HTTP. Missing samesite='Lax' or 'Strict' enables CSRF. Missing max_age means no client-side expiration enforcement. Combined with AUTH-VULN-03 (HTTP only), cookies interceptable on network."
    },
    {
      "ID": "AUTH-VULN-05",
      "vulnerability_type": "Transport_Exposure",
      "externally_exploitable": true,
      "source_endpoint": "POST /token, GET /company/{company_id}/jobs, POST /edit_profile/{company_id}",
      "vulnerable_code_location": "/app/main.py lines 87-97, 105-115, 152-162 (no Cache-Control headers set)",
      "missing_defense": "No Cache-Control: no-store or Pragma: no-cache headers on authentication responses. Sensitive authenticated pages lack cache prevention.",
      "exploitation_hypothesis": "An attacker with physical access to a victim's device can extract authentication tokens and sensitive data from browser cache and history files, as authentication responses and authenticated pages may be cached locally.",
      "suggested_exploit_technique": "cache_extraction",
      "confidence": "Medium",
      "notes": "No response.headers['Cache-Control'] set anywhere in main.py. Login response, jobs listing (contains flag for admin users), and profile pages all lack cache prevention headers. Browser may cache sensitive data on disk. Search for 'Cache-Control' in main.py returns no results."
    },
    {
      "ID": "AUTH-VULN-06",
      "vulnerability_type": "Abuse_Defenses_Missing",
      "externally_exploitable": true,
      "source_endpoint": "POST /token",
      "vulnerable_code_location": "/app/main.py:87-97 (no rate limiting) and line 21 (no middleware configured)",
      "missing_defense": "No rate limiting on login endpoint. No per-IP or per-account restrictions. No SlowAPI, FastAPI-limiter, or similar libraries in requirements.txt. No middleware configured on FastAPI app.",
      "exploitation_hypothesis": "An attacker can perform unlimited brute-force login attempts against the authentication endpoint without throttling, successfully guessing weak passwords like 'demo' or testing credential stuffing attacks from leaked databases.",
      "suggested_exploit_technique": "brute_force_login",
      "confidence": "High",
      "notes": "Requirements.txt contains no rate limiting libraries. Application instantiation at line 21 shows no middleware: app = FastAPI(). Each login attempt triggers expensive bcrypt verification (line 48 in authenticate_company) which could also be exploited for DoS. Combined with AUTH-VULN-08 (default weak passwords) and AUTH-VULN-14 (no password policy), enables practical brute-force."
    },
    {
      "ID": "AUTH-VULN-07",
      "vulnerability_type": "Abuse_Defenses_Missing",
      "externally_exploitable": true,
      "source_endpoint": "POST /token",
      "vulnerable_code_location": "/app/models.py:6-12 (Company model) and /app/main.py:44-50 (authenticate_company function)",
      "missing_defense": "No account lockout mechanism after failed login attempts. Company model has no fields for failed_login_count, account_locked, or lockout_timestamp. No tracking or enforcement in authenticate_company function.",
      "exploitation_hypothesis": "An attacker can continuously attempt authentication against a target account without being locked out, enabling persistent brute-force attacks even if rate limiting were added, as the account itself is never disabled.",
      "suggested_exploit_technique": "password_spraying",
      "confidence": "High",
      "notes": "Database schema at models.py:6-12 shows Company table contains: id, name, hashed_password, is_admin. No lockout-related fields. Authenticate_company function (lines 44-50) returns False on failure with no side effects to track attempts. No CAPTCHA after repeated failures. Combined with default credentials (AUTH-VULN-08), attacker can keep trying indefinitely."
    },
    {
      "ID": "AUTH-VULN-08",
      "vulnerability_type": "Weak_Credentials",
      "externally_exploitable": true,
      "source_endpoint": "POST /token",
      "vulnerable_code_location": "/app/main.py:58-62 (startup event handler with hardcoded credentials)",
      "missing_defense": "Three default accounts with hardcoded passwords created on every startup. Admin account 'company2' uses deterministic password. No forced password change on first login.",
      "exploitation_hypothesis": "An attacker can log into the application using default credentials demo/demo, company2/ajsdasd987asd87as7da9, or company3/password3, gaining immediate authenticated access including admin privileges for company2 which has access to private jobs containing the flag.",
      "exploitation_hypothesis": "An attacker can successfully authenticate using one of three known default credentials, with company2/ajsdasd987asd87as7da9 providing immediate admin access to private jobs containing the flag.",
      "suggested_exploit_technique": "credential_stuffing",
      "confidence": "High",
      "notes": "Startup handler deletes all data (crud.delete_all) then recreates accounts. company2 has is_admin=True at line 60. Admin users can view private jobs (line 112 check). Private job with flag created at lines 77-82. Default credentials are: demo/demo (id=1, non-admin), company2/ajsdasd987asd87as7da9 (id=2, admin), company3/password3 (id=3, non-admin)."
    },
    {
      "ID": "AUTH-VULN-09",
      "vulnerability_type": "Login_Flow_Logic",
      "externally_exploitable": true,
      "source_endpoint": "POST /token",
      "vulnerable_code_location": "/app/main.py:44-50 (authenticate_company function)",
      "missing_defense": "Observable timing difference between non-existent users (~1ms) and existing users with wrong password (~100-300ms due to bcrypt verification). No constant-time password verification for non-existent users.",
      "exploitation_hypothesis": "An attacker can enumerate valid usernames by measuring response times for authentication attempts. Fast responses indicate non-existent users, while slow responses confirm user existence, allowing the attacker to build a list of valid accounts to target.",
      "suggested_exploit_technique": "account_enumeration",
      "confidence": "Medium",
      "notes": "Lines 46-47 return False immediately for non-existent users. Line 48 calls verify_password which performs expensive bcrypt hashing for existing users, creating measurable timing side-channel (CWE-208). Fix would hash against dummy value even when user doesn't exist. Combined with AUTH-VULN-06 (no rate limiting), attacker can rapidly enumerate usernames. Error message at line 92 is generic but timing reveals truth."
    },
    {
      "ID": "AUTH-VULN-10",
      "vulnerability_type": "Login_Flow_Logic",
      "externally_exploitable": true,
      "source_endpoint": "POST /token",
      "vulnerable_code_location": "/app/main.py:40-41 (create_access_token) and lines 87-97 (login handler)",
      "missing_defense": "Session ID not rotated after successful authentication. Token generation is deterministic - same user always gets identical token. No nonce, timestamp, or random component.",
      "exploitation_hypothesis": "An attacker can perform session fixation attacks by pre-calculating tokens for target users and setting them before authentication, or by predicting future session tokens since generation is deterministic based solely on company_id.",
      "suggested_exploit_technique": "session_fixation",
      "confidence": "High",
      "notes": "Token for company_id=1 is always 'MQ==' on every login. No uniqueness between sessions. Create_access_token uses only base64.b64encode(data.encode()) with no randomness. Login flow at lines 87-97 doesn't check for existing sessions or generate unique identifiers. No session rotation logic. Enables session fixation and predictability attacks."
    },
    {
      "ID": "AUTH-VULN-11",
      "vulnerability_type": "Session_Management_Flaw",
      "externally_exploitable": true,
      "source_endpoint": "N/A - Missing logout endpoint",
      "vulnerable_code_location": "/app/main.py (no logout endpoint exists)",
      "missing_defense": "No logout functionality implemented. No endpoint to clear access_token cookie or invalidate sessions server-side. No session tracking mechanism to revoke tokens.",
      "exploitation_hypothesis": "An attacker who obtains a valid session token (via forgery, interception, or XSS) can maintain indefinite access as users cannot terminate their sessions, and there is no mechanism to revoke compromised tokens even after breach detection.",
      "suggested_exploit_technique": "session_hijacking",
      "confidence": "High",
      "notes": "Grep for logout/signout patterns returns no results. Only endpoints are: /, /token, /ping, /company/{id}/jobs, /edit_profile/{id}. No delete_cookie or clear_cookie calls. Models.py has no sessions table. No server-side token storage for revocation. Once token is obtained, it remains valid forever. Combined with AUTH-VULN-02 (no expiration), compromised tokens cannot be invalidated."
    },
    {
      "ID": "AUTH-VULN-12",
      "vulnerability_type": "Session_Management_Flaw",
      "externally_exploitable": true,
      "source_endpoint": "POST /token",
      "vulnerable_code_location": "/app/main.py:96 (set_cookie call missing samesite attribute)",
      "missing_defense": "Session cookie set without SameSite attribute (no Strict, Lax, or None specified). Cookie sent with cross-site requests, enabling CSRF attacks.",
      "exploitation_hypothesis": "An attacker can create a malicious website that submits authenticated requests to the application from victims' browsers, leveraging their existing session cookies to perform actions like profile updates or privilege escalation without the victim's knowledge.",
      "suggested_exploit_technique": "csrf_attack",
      "confidence": "High",
      "notes": "Cookie config at line 96: response.set_cookie(key='access_token', value=f'Bearer {access_token}', httponly=True). No samesite parameter. Default browser behavior sends cookie with cross-origin requests. POST /edit_profile/{id} endpoint has no CSRF token validation, accepts form data. Attacker can host page with auto-submitting form to /edit_profile/1?is_admin=1 that executes when victim visits."
    },
    {
      "ID": "AUTH-VULN-13",
      "vulnerability_type": "Token_Management_Issue",
      "externally_exploitable": true,
      "source_endpoint": "POST /token and all authenticated endpoints",
      "vulnerable_code_location": "/app/main.py:17 (ACCESS_TOKEN_EXPIRE_MINUTES unused) and lines 131-149 (validate_token no expiration check)",
      "missing_defense": "Token expiration not implemented. ACCESS_TOKEN_EXPIRE_MINUTES=30 constant defined but never used in token creation or validation. No max_age on cookie, no expiration claim in token.",
      "exploitation_hypothesis": "An attacker who obtains a valid token through any means (network interception, XSS, physical device access, or forgery) can use that token indefinitely as there is no expiration enforcement, maintaining persistent unauthorized access.",
      "suggested_exploit_technique": "token_replay",
      "confidence": "High",
      "notes": "Line 17 defines ACCESS_TOKEN_EXPIRE_MINUTES=30 but it's never referenced in create_access_token (lines 40-41) or validate_token (lines 131-149). No datetime expiration in token payload (tokens are just base64 company_id). Cookie at line 96 has no max_age or expires parameter. Once issued, tokens valid forever. Combined with AUTH-VULN-11 (no logout), creates permanent session risk."
    },
    {
      "ID": "AUTH-VULN-14",
      "vulnerability_type": "Weak_Credentials",
      "externally_exploitable": true,
      "source_endpoint": "POST /token",
      "vulnerable_code_location": "/app/schemas.py:17-20 (CompanyCreate schema) and /app/main.py:87-97 (no validation)",
      "missing_defense": "No password complexity policy enforced. CompanyCreate schema defines password as plain str with no validators. No minimum length, no character requirements, no common password rejection.",
      "exploitation_hypothesis": "An attacker can successfully compromise accounts through brute-force or dictionary attacks using common weak passwords, as the application accepts trivially weak passwords like 'demo' (4 characters) or 'password3' without any strength requirements.",
      "suggested_exploit_technique": "password_spraying",
      "confidence": "Medium",
      "notes": "CompanyCreate schema (schemas.py:17-20) has password: str with no Field validators. Default passwords in startup include 'demo' (4 chars), 'password3' (9 chars but dictionary word). No server-side validation in POST /token handler. Combined with AUTH-VULN-06 (no rate limiting) and AUTH-VULN-07 (no lockout), enables practical brute-force. Password hashing at crud.py:18 is secure (bcrypt) but policy is absent."
    }
  ]
}