
{
  "vulnerabilities": [
    {
      "ID": "AUTHZ-VULN-01",
      "vulnerability_type": "Horizontal",
      "externally_exploitable": true,
      "endpoint": "GET /api/user",
      "vulnerable_code_location": "/frontend/pages/api/user.ts:35",
      "role_context": "Any authenticated user",
      "guard_evidence": "No ownership check exists - endpoint extracts uid from JWT token and directly queries database without validating if the requesting user owns that uid. Code at user.ts:35 calls fetchUser(decodedToken.uid) without any authorization validation.",
      "side_effect": "Read other users' PII (name, email), financial data (account balance), and privilege flags (isMaster). Enables complete user enumeration and privilege discovery.",
      "reason": "The endpoint blindly trusts the uid claim in the JWT token after signature verification. With the exposed JWT secret (2kI0Zu7N6ptVPDurCTfqBGVCd+qpaSFO6m4/20SCZQU=), attackers can forge tokens with any uid value and access any user's sensitive data without ownership validation.",
      "minimal_witness": "1) Obtain JWT secret from .env file. 2) Forge JWT with target user's uid (e.g., uid:3789 for Nayla Sanches). 3) Call GET /api/user?token=<forged_jwt>. 4) Receive target user's full profile including name, email, balance, and isMaster flag.",
      "confidence": "high",
      "notes": "Database has 5 users: uid 9666 (admin, isMaster=1), uid 3789, 4890, 6785, 7771 (regular users, isMaster=0). All users have balance data ranging from 1991 to 7990 M$. The JWT secret is hardcoded in /frontend/.env and committed to git repository."
    },
    {
      "ID": "AUTHZ-VULN-02",
      "vulnerability_type": "Horizontal",
      "externally_exploitable": true,
      "endpoint": "GET /adminpanel/profile",
      "vulnerable_code_location": "/frontend/app/adminpanel/profile/page.tsx:8",
      "role_context": "Any authenticated user",
      "guard_evidence": "No ownership check exists - page calls checkSession(token) which validates JWT signature but does not verify if the authenticated user can only view their own profile. The uid from the JWT determines whose profile is displayed without any ownership validation. Missing check: if(authenticated_uid !== profile_uid) deny().",
      "side_effect": "View other users' complete profile pages including name, email, balance, and for admin (uid=9666) the CTF flag. Enables horizontal privilege escalation to view any user's sensitive profile information.",
      "reason": "The profile page trusts the uid claim in the JWT to determine whose profile to display. There's no distinction between 'who is authenticated' vs 'whose profile to show'. With the exposed JWT secret, attackers can forge tokens for any uid and view their profiles.",
      "minimal_witness": "1) Obtain JWT secret from .env. 2) Forge JWT with target uid (e.g., uid:4890 for Murilo Mac). 3) Set forged token as cookie. 4) Navigate to /adminpanel/profile. 5) View target user's profile page including their name, email, and balance.",
      "confidence": "high",
      "notes": "This vulnerability combines with AUTHZ-VULN-03 to enable flag capture. By forging a JWT with uid=9666 (admin), attackers can view the admin's profile which displays the flag. The profile rendering occurs at Profile.tsx:20-42 with all sensitive data exposed."
    },
    {
      "ID": "AUTHZ-VULN-03",
      "vulnerability_type": "Vertical",
      "externally_exploitable": true,
      "endpoint": "GET /adminpanel/profile",
      "vulnerable_code_location": "/frontend/app/adminpanel/profile/page.tsx:10-12",
      "role_context": "Any authenticated user can escalate to Master Admin (isMaster=1)",
      "guard_evidence": "No role check before rendering profile - page only checks if(session.error) but does NOT validate if(session.user.isMaster === 1) before rendering privileged content. Flag display is controlled by client-side React conditional in Profile.tsx:39 without server-side role enforcement.",
      "side_effect": "Access Master Admin privileges and view CTF flag. The flag (process.env.FLAG) is displayed on the profile page when isMaster=1, which can be achieved by forging JWT with admin uid=9666.",
      "reason": "The application fetches isMaster value from database based on JWT uid but never validates if the requester SHOULD have that role. Missing server-side check: if(session.user.isMaster !== 1) { redirect('/adminpanel'); }. With exposed JWT secret, regular users can forge admin token and escalate privileges.",
      "minimal_witness": "1) Obtain JWT secret: 2kI0Zu7N6ptVPDurCTfqBGVCd+qpaSFO6m4/20SCZQU=. 2) Forge JWT with admin uid: {uid: '9666'}. 3) Sign token with exposed secret. 4) Set as cookie. 5) Access /adminpanel/profile. 6) Server fetches isMaster=1 from database for uid=9666. 7) Flag displayed via Profile.tsx:39 client-side conditional.",
      "confidence": "high",
      "notes": "This is the primary path to CTF flag capture. Admin user is William Rogers (uid=9666, email=will.rogers@manapool.com, isMaster=1, balance=7990). Flag is displayed at Profile.tsx:39 with condition {props.isMaster && <p>{flag}</p>}. No server-side role guard protects this privileged resource."
    },
    {
      "ID": "AUTHZ-VULN-04",
      "vulnerability_type": "Context_Workflow",
      "externally_exploitable": true,
      "endpoint": "GET /logout",
      "vulnerable_code_location": "/frontend/app/logout/page.tsx:9",
      "role_context": "Any user who has logged out but whose token was stolen/intercepted",
      "guard_evidence": "Client-side only logout - logout page only calls Cookies.remove('token') to clear browser cookie. No server-side token revocation, blacklisting, or session invalidation. JWT tokens remain valid until their 1-hour natural expiration regardless of logout action.",
      "side_effect": "Stolen or intercepted JWT tokens continue to work for up to 1 hour after user logout. Enables post-logout session hijacking and prevents emergency session termination. Attacker can continue accessing /api/user and /adminpanel/profile with stolen token.",
      "reason": "JWTs are stateless with no server-side session store. The logout workflow only removes the cookie client-side but server has no knowledge of 'logged out' state. No database session table exists (only users table). Once a token is stolen, the legitimate user cannot revoke it even by logging out.",
      "minimal_witness": "1) Victim authenticates, receives JWT valid for 1 hour. 2) Attacker intercepts token (XSS, network sniffing, stolen cookie). 3) Victim clicks logout (only removes their browser cookie). 4) Attacker continues using stolen token: GET /api/user?token=<stolen> or sets cookie and visits /adminpanel/profile. 5) Token remains valid for remainder of 1-hour window.",
      "confidence": "high",
      "notes": "This vulnerability extends the attack window for AUTHZ-VULN-01, 02, and 03. Even if a user suspects compromise and logs out, stolen tokens remain exploitable. No revocation mechanism exists - no token blacklist table, no session ID tracking, no server-side logout endpoint. The cookie expiration is 7 days (LoginForm.tsx:30) but JWT expiration is 1 hour (auth.ts:47), creating a mismatch."
    }
  ]
}